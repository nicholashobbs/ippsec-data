 what's going on youtube this is ipsec and this is a video series i wanted to do for a long time however um i just didn't know how to do it responsibly that being said i think there's a lot more of the like commercial c2s coming into play and it makes it really hard to understand what they're doing and if you're not ready for it it may blindside you in the future so i decided to put together a series or at least start a series on building small components of the c2 not the c2 itself but if we break it up into small chunks we'll be able to understand exactly how it works under the hood hopefully build detections or learn how to reverse it whenever we do come across it so in this video we're going to look at how people may bundle configs in an actual executable so the operator can change it out without having source code to that executable i call that malleable agent config i'm not sure if i'm using the terminology correct but that's we're going to call in the video it's all going to be done in c plus because that's the only language i'm really familiar with that doesn't involve some type of embedded virtual machine learning rust is on my to-do list but for now we're just going to stick with c with that being said let's jump in before we go into showing a live demo of doing some coding with some malleable c2s let's just start off by showing how they work in the wild and of course the very first one we're going to pull up is cobot strike so we're going to search malleable cobalt strike and go to the c2 profiles github and we can take a look at one the meterpreter.profile is a good example and we can see various things so the default sleep time is 100 milliseconds so this is a very noisy one we can see the default spawn 2 is going to be notepad.exe um this is probably a bad one to do because not many people target notepad if this was a like real op i would probably expect to see it and we're fault.exe w-e-r-f-a-u-l-t that is like the error handler for windows and also gpupdate.exe is another big one but being able to extract this information from the beacon that you find in your environment is super handy because now you know exactly what to hunt for and you can get a bunch of other parameters like the user agent it's going to be using but being able to extract the config or the malleable c2 profile from the beacon is super handy um i can show you one that i use i can't really pull up cobalt demos live because i don't have a copy of the software but kind of how i use the malleable c2 and i'm not sure if i'm going to be using this terminology correctly um this is just what i call it so i'm going into stage one i have this is based off of silent break securities course it has a fork i have a lot more features in it but the actual layout is from them but we can see various config options so if i go and download scattershot i'm going to do curl dash k o i'll call it test.exe and then we'll do navi.dev files scattershot.exe so i download it and if i do a strings against this uh oh i called it test i don't see any of these parameters because it's all um xored in this which we're going to go into later in the video i'll show how i did the malleable c2 part of this but i'm going to do grep dash i navi and we don't see this string anywhere in here now what i'm going to do is we're going to put this with four a's and download it again so one two three four and i'm going to save and i'm just going to go back up here try to download the same exact thing test2.exe and now we're going to do a hex dump of both of them so test.exe to one dot hex and test2.exe we'll go to two.hex and this just lets us do a quick diff and we can see exactly where they differ now this is going to be the um c2 like the actual config and what i'm going to do is go into cyber chef and show how to um pull it and this is a super simple like sample because i'm just doing a simple xor and if this doesn't make sense it hopefully will by the end of the video so this is just doing a live demo to kind of show the value of it so from hex dump we paste this in and get rid of those and then we can say xor let's try xor brute force does this work and we're just scrolling down till we see something that we want let's see did this get it i've never used extra brute force in this oh this is doing two byte keys uh key length wait key one two sample offset known plaintext key oh come on scheme i was trying to um let's see it should be 51 i think yeah there we go it did brute force it so if we're looking for strings we have it now we did an xor brute force it's 51 i kind of cheated because i knew that because i wrote this piece but if we just do um an xor now and key is going to be capital q and we change it to utf now we can start getting the actual c2 so i'm going to go to this spot in the hex dump so let's do less one dot hex paste this and i'm going to grab a bunch of data and now we can start pulling back pieces of how the config is written so this is going to be super helpful because now like if you do this in your implant it's a way for you to modify a bunch of parameters in your actual executable without giving the source up and if you're like on the blue team watching this i'm going to do some light reverse engineering after we do it so you can kind of try to piece together how to pull apart a c2 that's using a config like this so with all that being said let's just jump in and do the coding before we get into anything complex i'm just going to create a simple hello world so first we need to include i o stream so we can do a print statement so in main or c out i should say so standard c out we need to direct please subscribe here put a line break and if i compile this we'll call it c2 all it does is print please subscribe so the next step i want to do is i want to take this string and put it in a separate file called config.h so we can do std string config buffer is equal to thank you and i want to make that a constant save that and over here we can now include config.h and we'll print this one out as well so i'm going to do config buffer so let's compile and we have please subscribe and thank you if i want to make sure everything's on the same line i can just put a line break there we can compile it again and we have it now the issue i have right now is thank you is only going to be the like correct length so if i do echo dash n thank you wc-c nine characters and if i xxd my program look for thank you we can see we have the nine characters and then the null byte terminating it so if i wanted to modify this binary afterwards because we can just change any of these pieces of text to be something else it has to be within this size so the easiest way i've got around that is i don't use a string here i'm just going to do a let's see static unsigned care config buffer 2000 and we can say thank you uh i'm gonna say very much so we save this compile and execute it we have thank you very much and if i go back to that same xxd we have a bunch of null bytes afterwards now i could have just padded the string so if we go back here and comment this one and i put a bunch of null bytes like this that would work as well so save g plus plus like we have thank you there if i go into xxd and we look at it it did put the external bytes there um i just really like having the ability to set it numerically because i just think that code is cleaner so the next piece is we're going to be passing a json string in now if i was doing this for an actual implant i probably wouldn't want to use json just because it's a lot of wasted space but for simplicity of explaining things json works very nicely so let's now um let's see we put a bracket and let's just do first name and this will be please see i think that is correct and we need a probably second thing in our json so this will be migrate because most like malleable c2s will give you the ability to automatically migrate into a process so this one will be subscribe i think that's good i escaped all the quotes so when i now compile this let's see if it works c2 okay that looks good let's just validate this is proper json so i'm going to v main let's take this string out compile it again dot slash c2 pipe it to jq and since jq did not error we have proper json here so the next piece is we should grab a json library and i use one pretty much for everything whenever i need json and c plus plus let's see if i can find it real quick uh let's search github i think this is it um here see do they have a release i actually haven't downloaded this in a while right here so json.hpp okay let us now move that into our directory so cp downloads json.hpp here and now if we wanted to we could edit main to use it so let's include json hbp and then we have to initialize it so we can call what is it whoops where am i there we go let's do n l o h m a n n json object will be j and now we have to um parse perset so json parse config buffer and what this is going to do is now we can just um call items in this json like this so hostname and migrate was the options so i can do j hostname like that and hostname is capital so let's give it a capital h save it g plus plus to compile and if i do c2 we have just the hostname we could change that and call it migrate or do a second one and say migrate recompile and execute so we have please subscribe now this isn't the best way to refer to the config we want to make it a structure globally through the program so let's not parse it here we're going to actually create a another file and this one's going to be config.c so we'll call config.c and we will call this config initialize and we're going to pass it a structure i'm going to call create this config t struct in a second config so we're giving it the pointer um so let me just type this out and we can explain it so standard string uh we'll call this config str there we go so go up into our config.h and now we should define that struct so struct config t std string hostname std string migrate now we do type def and then we can copy this header over and let's see i always hate copying from vi so i'm just going to less it and then copy it so we have it in our header okay oh i don't know why that just sometimes i hate when it auto does those indents so let's do comments real quick initialize config and we can say param out config let's config t param n config string and that's a string okay so now we have to initialize the config so essentially we just do what we did on the config.h or main dot c so json j is equal to json purse config string and we can say config to first name is equal to j first name and config this will be migrate sql to j migrate so that should be good we'll probably have to include config.h and json.hpp and just exit that let's see i'm trying to make this look better on the screen there we go so now in this main we can say standard string result converting the config buffer into a string and then config initialize conf result and we want to create that comp object so config star comp is equal to new would i call it i think config let's do less config.h and let's see dare not save it that's going to be sad b config.h swear i had more i guess i did not save it v config.h let's see config.c let's just retype it so i need to grab this header vconfig.h delete that and we need to [Music] struct config t string hostname link that name this migrate okay type def struct config t config there's no way this is going to work okay config initialize conf result so now if all went well we can do c out conf hearst name and anywhere in our code we can pull the hostname via that variable conf to so if i do g plus plus let's see config initialize something errored i'll probably have to do config.c there give it both files and let's see v config.c include higher stream i don't think we have to do that there string in namespace standard does not have type that's probably config.h we have to include fire stream do we have anything else there don't think so so now our c2 works or no it's not a c2 i guess um but now we have the malleable c2 plate piece done so if i also wanted to we could say um put a space there and comp to migrate g plus plus execute and we have please subscribe so if we look at it we can easily see that the json string exists and then we have a bunch of null bytes afterwards because we defined it to be 2000 bytes so the next piece is we need to create a python script to quickly be able to replace these variables to make use of the malleable c2 otherwise we're just like hard coding variables and that's it there was no point of doing this the whole point is to code something that can like patch it so let's do import json and then let's create a json string so config is equal to nothing and then config hostname is equal to let's just call it ip and then the next variable we'll do is migrate and we'll call this one sec and if we print uh json.dumps config and execute well uh we want to execute the string so python3 patch.pi we can see we've outputted the json string so now we want to get this into our program so i'm going to go back to xxd goes around 36 280 and we're going to copy the string because this is the string we want to find because it's the beginning of our config so let's go back into patch and then we're going to um find that string so with open c2 i did not mean to close that read binary as bin file then we can say byte data is equal to byte array then file.read so now we've just read that whole binary data we can close it so bin file.close and now we can find the offset so offset is equal to byte data.find and paste in the string we want and if i print offset it's going to give me a number hopefully right two two one eight two four so i'm guessing at that index this is where the string starts so now let's just reopen this file but this time with read write and then we can do bin file dot seek to the offset so now our cursor is right at the start of the json we can say bin follow dot right and then the config so what we have to do here is say config is equal to that and we call patch.pi and the config wants a byte value so we can fix that with just adding a dot encode and if we go to execute it we have an error so i'm going to look at what we wrote and we see what happened so and see we got um these strings terminate by a null byte and because i did not calculate like all the padding and we didn't like erase this it's reading this whole thing as a string and the json library is barfing because it's getting value after where it should close now we could do a bad fix to this and say plus b bax plus x 0 0 to put a null byte afterwards so now even though we have not cleaned out everything we put a null byte so this terminates the string read so the json library should be happy because it's going to read up until this byte so let's do um dot slash c2 and it is but i'm not happy i don't like leaving that junk behind so let's calculate padding so i'm going to get rid of this and we're going to say padding is equal to backslash x00 on null byte times the 2 000 bytes we have minus the length of the config and i'm going to say we have to close that we can say config is equal to config plus padding so now when i run this um we can xxd 36280 we now have successfully erased everything afterwards so it's just a little bit cleaner so the next piece of this puzzle is we have to um encrypt this because we want to um prevent ourselves from being in strings because that's never a good thing so if we just like string c2 and grep for ip we can see the entire config is here so let's xor it so i'm going to create a xor i'm going to say um we'll just hard code the string again probably something you should do a bit better of a job but i'm not going to worry about it so that will be each character and we want to xor with a capital q i don't know why everything uses like a capital q to xor but i see that more often than not so i'm going to replicate it and for list comprehension we do 4 i n range 0 length of data 3. there we go and let's see config xor config there python3 patch.pi invalid syntax on config so that looks like an extra prince okay there we go let's xxd 36280 so now this looks to be encrypted well the downside to this though is now we're not going to be able to just run it again because we've encrypted it so it's going to be really hard to do the fine string we could because it's just a static one byte xor we could just search for the string and do it but i'll leave that exercise for you um now we have to edit the c code so the fun part of the job so let's edit main.c and right here we're going to create a new thing to decode it so we'll call it xor and we're going to i guess call this encoded string and then there we go so standard string decoded string is equal to nothing so we're just initializing that and then int key is equal to let's see man ascii q that is 81. we want the decimal value so if we go all the way up decimal is this one so 81 now we want to loop through every character so c is equal to x string 0.02 that okay and then decoded string plus equals c xor with the he and then modulo 255 to make sure it is a byte so if we if our xor goes over 255 it um i guess rotates back to zero forget the correct word it's just like i don't know um modulo you should just google m-o-d-u-l-o if we go to like ipsec dot rocks i'm sure i explain it so um m-o-d-u-l-o modulus there we go this is what you probably want to watch obscurity right there but let's finish this program so after this we want to return the coded string and now the issue here though is we don't want to unxor all or null bytes because if we do then they're no longer null bytes and to be read by the um like parser so we want to put a breakpoint in so if c is equal to negative one break and then in our python program i think we just add a ff so let's change this padding down one so one 1999 or actually we can leave 2000 and then i'll add minus one because i'm adding one byte in this config so right here and do b backslash x f f so that should match that negative one okay here goes nothing so g plus plus we're going to compile everything and unqualified id before xor v main.c oh um i wonder if i can't use xor let's see let's call this decrypt underscore xor and i'm probably gonna get like it's defined but not used which is fine oh don't even get that but i realized i did not put it in my program so decrypt underscore xor and we put it right here on the config buffer so before we send it to the config initialize we're going to xor it to try to decrypt it so let's hope this works looks good now it's going to fail here because we have not ran our patcher right because if we now xxt 36280 it's still plain text so let's do our patch so python3 patch.pi that looks good 36280 it is encrypted and then we have this ff so as long as negative one matches that we'll be fine well and that we like wrote a decryption routine correctly but we'll see there we go so that is that and if we wanted to we can now compile this again and we can edit patch.pi and say thank you very much for subscribing please leave a comment so patch patch python 3 patch c2 and we have the full program and now finally let's just try to reverse it so i'm going to open up geeja and we're going to look at what this program looks like in a decompiler and then just use gdb to step through it i know geidra now has a disassembler of its own but i'm actually not sure how to work that thing so i'm just going to go with the way i know right now and we'll tackle that um kidro built in debugger in a later video so i'm just pressing i to import the c2 binary and this is going to be super easy because it's not stripped so we should have all the function names and everything there let's see we can go to exports we have our a second once it finishes loading we can see in the bottom right it loading once it's done go to exports was main there we go go to main and we can see the function decrypt xor so what we're going to do is switch over to just gdb so gdb dot slash c2 and i can do a dis as main to make sure we can see all this and i can just break here run it and we want to break right on this decrypt routine so i'm going to break there we'll continue i'm going to step into it and then i'm going to do another disassembly so we can look at this function and i'm going to break on the return value so we can break here and i'm actually going to rerun this because i missed out on showing something i want to run so we're at the beginning we go in here we can look at the strings on right before this it's moving rax into rdi if we look at that it's not what we want i don't think maybe that's the string let's see run it let's see what it's doing so this is building the stack and we're at the decrypt now oh rsi rsi is the argument um that's passing so we can x slash s to examine string or an rsi and yep this is the um xord string so if we go back into the xd output of our c2 was it three two six eight zero uh that's not where it is let's just search for a lot of null bytes uh let's see 680 where is it i lost where it is um let's see we can if i search for a star s maybe let's try that so backslash star s there we go um three six two eight zero i think i reverse some bytes but we can see this string and then like two thousand um null bytes so we know that is definitely the encrypted string so we step into this and then we do another disassembly and we can break right here and this is like the best way to get comfortable with doing some type of reverse engineering is you have a binary that you wrote so you know exactly what it should be doing and then you just play around in it so right here let's see did we just end on this return we did so if i go up here we should see rdi and the decrypted string so now we could if we wanted to reverse the python we did before to look for that star s i think it was um x slash s r s i yeah we could look for this string and then pull out up until a backslash xf and then do the xor routine herself and if we didn't know what the xor key was we can always step in do a disassembly and let's see is it obvious anywhere here uh [Music] i don't think so see unwind maybe if we look at the decrypt xor routine here look at exactly what this is loading guessing local 20 i'm guessing that's the cue so let's do man ascii look at capital q 51 so when we used we're in decimal but gidra is showing us in hex so right there it's loading that xor string and then while it's doing a loop does not equal null byte or negative one remember that's the ff we put it's doing a x row right here so we can see local 19 local 19 is just looping through each character in that one string that we have um uh this is the pain see do we have it up here it's looping through what is this so it's looping through each of these characters so this is 19 19 uh probably one character so it's looping through that and then doing xo with 20 which again is q so this would be kind of how you analyze it if you wanted to make it tough and i'm not going to analyze it after we do this if you want you can probably check out some of my videos where we do stripped binaries but if i do g plus plus and then add the dash s flag this is going to make it a lot tougher because now when i do like gdb dot slash c2 and i say break main main is not defined so we have to find like the starting point if we want to analyze it real quick we can open up c2 put it here analyze analyze okay wait for it to load everything and what we're going to see or well what we're not going to see is all the function names like we have a lot less exports because it didn't put that whole table there so if we want to go to the main we have to go to the entry and then hit the function on the lib c start main and now this should look familiar actually um we didn't run a python program so it's not obfuscated yet so um let's run that python3 we call it patch.pi so now we can import c2 yet again analyze yes okay so once this finishes we can go look at that so export entry function so now it's just a data if we go into this here's the xor routine we can kind of still see it but all the names are wrong so if you want to go play around in gdb to analyze it this way that would be a fun task to do after the video but hopefully um the whole malleable c2 stuff has been like demystified so if you enjoyed the video let me know in the comments take care and i will see you all next time