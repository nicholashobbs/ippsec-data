 what's going on youtube this is ipsec and i recorded this video a few weeks ago after a live stream on twitch where we did some instant response on the hackthebox pro labs offshore essentially on one of the linux boxes we came across some malware that was running but the odd thing about it is it had a deleted file it was based off of so we couldn't identify exactly what that malware was unless we extracted it from memory which we used dd to do i later found out you could have also just copied the proc self exe file to extract it additionally we extract the heap memory so we can get some information about the malware itself to find out it is metal slash meterpreter um we'll also confirm that by doing some ghidra and gdb against it just to kind of explore how it works so hope you guys enjoy this video so here we are on nexo one if i do a ps ef on forest we can see a few suspicious things right at the bottom the first is um let me do a less dash s this splunk reverse shell python script we looked into that on stream it's definitely suspicious but the main thing that i found really interesting is this temp jd dod file because i tried to go view it so if i do atlas on it it doesn't exist if we do lsla on temp we see that file just does not exist so i kind of wanted to know exactly what this was so my first thought was i went into proc and then 14180 because this is going to be the directory associated for this process and then we went into like the file descriptors and tried cutting a bunch of them see if we saw any info here spoiler we didn't we could do lsla and see what they are but nothing really helped here after a lot of digging we wanted to like recover this exe and my first attempts were well maybe i can like view this memory file and i can't i try to cat it doesn't work i do like dd and we do if equals mem let's set the block size equal to 1 and try to copy 10 bytes out of this and output file temp output we see we can't read it but what i did learn is if you go to the location where this process writes to you can dump things out of it we did a lot of other things like i couldn't do gdb to just dump it that way because we don't have gdb installed on this system and of course we also don't have any instant response tools installed in the system so those would probably be the ways i would do it or maybe i do it this way now just because i found out so if i do a cat on this maps file this is going to tell me where um everything is right we have it telling me this exe is deleted and it's at this location so the one piece of information you'll probably need for the next piece to make sense is this um dollar double parentheses we'll just translate hex into decimal so what i did was a dd and we can say input file is equal to mem block size is equal to one and then we want to skip all the memory until we get to this spot so we're opening up um the mem file and then not reading from it we're just skipping all the bytes up to here and then this is thousand this is eight thousand so i'm just going to count for one thousand so we're just going to read we skip here then read the next 1000 bytes and let's see bs get i think all we have to do is specify output file now so temp output and now we have a copy so i could do a file on temp output and we see it's elf which is good that's like a windows executable so everything's looking good uh the other thing i did was like an xxd on it and we can see it's really small like most of that 4096 bytes is just nothing and it's that way because i guess that's the default page size for memory so i can't allocate less than that in memory but um right now i'm thinking this is some type of stage thing because normally an executable when you xxd it does not fit on your screen so i know this is some type of stage thing meaning it's just going to either make a request out or set up a listener and then download shellcode or receive shellcode and then execute it right because there's not much else you can do with this amount of space so um we still don't know exactly what it is the next thing we could do is dump the heap so the heap is going to be where like all the um memory stuff is and there's probably going to be an l file embedded in this heap as well i don't actually know that i haven't dug that fart into it we just verified it was metal and called it a day so and metal is meterpreter for linux so we're going to copy this heap and this is 4 000 oh this is big i wonder if i can do like subtraction here i did not do this on stream we just copied three thousand bytes so we didn't copy the whole memory allocation now we are and we have to prefix this with zero x i can call this heap that looks like it may have worked strings temp heap less get a bunch of headers there's the passwd this is how we knew it was metal and then we have where it's talking to sending up some file descriptors um i guess it's on port four four three three or maybe it's four four uh four four three and a weird like strings thing displaying different things but we can see we have it's memory so just from those two commands we're able to um grab a bunch of good information do i have been walking this system i doubt i do so what i'm going to do is pause the video and we're going to copy output and heap to our box apologies for the sloppy cut um when i did the stream this was the first time doing this and then i kind of learned a little things i did a bit smoother in this recorded video that you're watching now and then after i finished i kind of um tweeted about recovering files and someone's like why don't just use the um exe in the proc and i was like wait what so um if you wanted to do that it's a much easier way we can go in oh it looks like there's a second person doing it or it's the same person but we can go into uh proc 14 180 and then we are using the mem file and the maps file but there's also this exe which is just a sim link to the executable section so if i cp exe to dev shm and i'm going to call it jd dod and we go into that directory we have the file here so yeah this is the other way to do it um we can xxd yet and see it kind of looks the same i guess um i think i did like temp output xxd temp output we probably have to head dash 20 let's do 15 13 that looks fine so xxd this do the other one and we can see they look identical t4 t4 for the ascii is matching up i'm assuming these other bytes match up as well so um just a different way we could extract it so um now let's switch over to my other machine where we will reverse this binary and find out exactly what it is so now we have both the files on our desktop the output is the elf heap is the heap and remember heap had the ip address but the main thing we want is output so i'm going to open up engine because that's normally my go-to for any type of reverse engineering and on stream we did not really like this ghidra output and we switched to a different application but again i just want to show you kind of a summary of what we did and this looks like the binary so i guess it was remembering where we were at but this is what it looks like let's see i'm trying to make sense of it i can't really um i know this is a syscall number but not sure why i know that from geeja i just know that from um reversing it outside of geija if we look at the shell code it makes a bit more sense i think all the metasploit shell code was hand crafted so looking at the disassembler view would be more helpful this is pushing a2 this ends up in eax and then every time you see int 80 that's it doing a syscall so if we look at a2 if we do echo let's do 0xa2 it is 162 and i go google linux syscalls this is the other mistake we had made in the stream we went here and went to 162 and saw oh this must be a sync right but if we do a file against this we know it's 32-bit and on this it says 32-bit sys calls coming soon so if i do linux sys calls 32-bit we can take a look at let's see maybe this and we want to go to 162. we can see that's nano sleep so that's asleep if we go back to guidro do we have any others let's see let's go int so 66 and two i'm guessing so going back here to his fork and we need to know what was it 66 102 if we look at 102 that is socket call so this is the one we actually want but the whole decompiler view sucked so the tool we had ended up using let's just exit this it's called cutter because it supports two different formats of the compiler so you can get it at cutter.re we saved it let's see downloads cutter we can analyze it um let's see it's in home ipsec home ipsec stream oh come on cancel select stream ir output so let's open this file we can analyze it and this is if we go down the bottom right we can change between gauge review which is this and we can do js deck which is the r2d compiler and we can see this is much better like it's converted the int 80 calls to be actual syscalls and then we can see like xerox 66 that's sending that there this goes into eax um 66 let's see so it's much more apparent what this is doing and then it does a weird thing just like the last one because it's handcrafted assembly if we wanted to we could go to google and i did not know where this was when i was streaming but after the stream i decided to look at it so if i go metasploit github source shellcode i think this is going to pull it up so this is the windows shell code i'm going to go back here we'll switch to linux and we want 32-bit so that's ia32 and we can do probably single reverse tcp shell i would think this is or maybe this is tcp let's see how many reverse are there sock reverse and tcp shell i mean just look at this one you can see kind of how it works it's a got actual document so um when you do the socket call it takes things in reverse order so at this memory address it's pushing it to the stack and that is one twenty seven zero zero one seven f i should make this bigger seven f is one twenty seven then you got zero then you got zero then you got one and then it pushes the port just converts this into hex and pushes it there so knowing all of this let's go and reverse this binary so i'm going to ch mod plus x output actually before we do that we thought this was metal just because of the heap if we graph it it's got the string metal in it which streams meterpreter um we can create our own copy so msf venom then dash p or dash l payloads to list payloads and i'm going to grab it for metal and i'll do a dash i because i'm not sure if it's a capital m a lowercase m but we can go and generate our own shell code for this so let's see we're going to do um [Music] interpreter let's see linux x86 this is going to be the stage list payload we don't want those we want the staged payloads so we definitely want to see a lot of slashes like this so let's see the difference is a slash after meterpreter and we can show the difference once we generate this so we do msf venom dash p specify my l host so 10 10 14 8 l port we'll do 9001 uh format is elf output um generated stager i should call that staged but it's fine so if i do file against this we have that elf and remember output is from the actual target and generate stager is ours so if i just xxd it we can see what it looks like it stops at c0 and it ends with like this right so if i xxd output we get a lot of zeros right but eventually at the top it stops around c0 same exact byte it stops and it stops with 80 right so this is looking very similar between these two so we know this is a staged payload so um what we could do is a gdb and i'm gonna do it against um we can do it output let's see gdb dot slash output and let's see i'm going to i'm not sure you'll be able to see this because of how i have the recording set up you cannot but what i'm doing right now is disconnecting the nic from my computer so if i do ipaddr we should see uh this is now disconnected if i ping 888 i can't whenever i reverse malware i like just disconnecting the nic and i also took a snapshot because i'm running executable from a user so we're going to do gdb on this um oh yeah this was a [Music] stripped binary so option i'm just going to get the memory address from geeja oh we could probably get it from cutter i just know where it is in geeja let's open this and we want to go to output so home ipsec stream ir output analyze yes come on so many prompts exports entry and then let's see where does this start at 54. so 8054 so if i run this let's do where's gdb run control c so it's got the same exact memory location so i'm going to break star 0x804 8054 i think 8054. awesome so i'm going to run and now we broke at the entry point right here so we see push 0 pop esi push oh 0x a yep then pop esi then a xor so we are where we think we are and i'm going to into 80 and when i go here i can go up to look at eax eax is set to 66. 66 let's see exactly what that is echo 0x 66 102 let's go back to our shell codes or syscall list one or two is the socket call awesome so where we where we yeah we are where we think we are but i don't see any um like ip addresses in stack so i'm just gonna go past this call because maybe this one is just like opening the socket or doing something um i'm guessing it matters based upon this number but i'm going to keep stepping through the code we get to the next um and to 80 which is doing a syscall and this number is different and also we see right here o a o a o e o a is 10 o e is 14 so that's 10 10 14 and then aa would be the user's ip address so if i do a a it is 170. uh we can do oac 10 o e confirm 14. so now we have confirmed or ran this 100 confirmation this is going to be metal just because all the shell code lines up and just from this staged payload we get the ip address it is calling out to um i think the next one was port i don't know exactly where that is the port was like 4433 and i'm guessing that's this but um doesn't look right yeah it's probably like a signed number or something but that's pretty much as far as we went so hope you guys enjoyed that enjoyed how to take that um file that's running on a linux system but someone deleted the executable so you can take it from the memory and then just doing that type of analysis so take care guys and i'll see you all next time